<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Surely,I am Joking</title>
    <link>https://danielyangmeta.github.com/</link>
    <description>Surely I am Joking</description>
    <pubDate>Tue, 24 Mar 2015 15:17:00 +0800</pubDate>
    <lastBuildDate>Tue, 24 Mar 2015 15:17:00 +0800</lastBuildDate>
    <atom:link href="https://danielyangmeta.github.com//feed.xml" rel="self" type="application/rss+xml"/>

  
    <item>
      <title>背包问题（1）</title>
      <description>&lt;h2 id=&quot;x01-&quot;&gt;0x01 背包问题&lt;/h2&gt;

&lt;h3 id=&quot;backpack&quot;&gt;Backpack&lt;/h3&gt;
&lt;p&gt;Given n items with size A[i], an integer m denotes the size of a backpack. How full you can fill this backpack? &lt;/p&gt;

&lt;h3 id=&quot;note&quot;&gt;Note&lt;/h3&gt;
&lt;p&gt;You can not divide any item into small pieces.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;If we have 4 items with size [2, 3, 5, 7], the backpack size is 11, we can select 2, 3 and 5, so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select [2, 3, 7] so that we can fulfill the backpack.&lt;/p&gt;

&lt;p&gt;You function should return the max size we can fill in the given backpack.&lt;/p&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 解题思路&lt;/h2&gt;

&lt;p&gt;这个解法好暴力，状态转移方程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result[j] = result[j - A[i]] + A[i], result[j];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 代码&lt;/h2&gt;

&lt;h3 id=&quot;c&quot;&gt;C++&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    int backPack(int m, vector&amp;lt;int&amp;gt; A) {
        // write your code here
        int result[100000] = { 0, 0, 0 };
	    for (int i = 0; i &amp;lt; A.size(); i++) {
		    for (int j = m; j &amp;gt;= A[i]; j--) {
			    if (result[j - A[i]] + A[i] &amp;gt; result[j]) {
			    	result[j] = result[j - A[i]] + A[i];
			    }
		     	else {
			    	result[j] = result[j];
		    	}
	     	}
    	}
    	return result[m];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;

&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    public int backPack(int m, int[] A) {
        // write your code here
        int[] result = new int[m + 1];
        for (int i = 0; i &amp;lt; A.length; i++) {
            for (int j = m; j &amp;gt;= A[i]; j--) {
                result[j] = Math.max(result[j - A[i]] + A[i], result[j]);
            }
        }
        return result[m];
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/algorithms-backpack.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/algorithms-backpack.html</guid>

      
      <category>Algorithms</category>
      

      
      <category>解题</category>
      
      
    </item>
  
    <item>
      <title>Logistic Regression</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;p&gt;Logistic 回归是一种输出预测概率的回归分析，可以用于回归也可用于分类。&lt;/p&gt;

&lt;h2 id=&quot;x01-logistic-&quot;&gt;0x01 Logistic 回归&lt;/h2&gt;

&lt;p&gt;Linear 回归是用于预测连续值得，有些时候我没需要预测一下离散值得因变量，这个时候就可以用 Logistic 回归。Loginstic 函数（Sigmoid 函数）是一种 S 形函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Gallery/2015/logistic-function.jpg&quot; alt=&quot;logistic function&quot; /&gt;&lt;/p&gt;

&lt;p&gt;logistic 的损失函数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Gallery/2015/logistic-cost-function.jpg&quot; alt=&quot;logistic cost function&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i = (1 : size(X, 2))
    hthetax = 1 / (1 + exp(-1 * theta&#39; * X(1 : size(X, 1), i)));
    f = f + y(i) * log(hthetax) + (1 - y(i)) * log(1 - hthetax);
end
f = -1 * f;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/Gallery/2015/logistic-min-cost-function.jpg&quot; alt=&quot;logistic cost function&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i = (1 : size(X, 2))
    for j = (1 : size(g, 1))
        g(j) = g(j) + X(j, i) * (hthetax - y(i));
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向量化实现能充分利用计算优势，所以在 R 和 Matlab 中都不提倡用 for 来计算矩阵。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;temp = theta&#39; * X;
hthetax = 1 ./ (1 + exp(-1 * temp));
size(hthetax)
size(y)
temp = y * log(hthetax)&#39; + (1 - y) * log(1 - hthetax)&#39;;
f = -1 * sum(temp(:));

temp = hthetax - y;
g = X * temp&#39;;

size(g)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 实验结果&lt;/h2&gt;

&lt;p&gt;这个实验做的就是大名鼎鼎的手写数字识别。&lt;/p&gt;

&lt;p&gt;Optimization took 31.642443 seconds.&lt;br /&gt;
Training accuracy: 99.3%&lt;br /&gt;
Test accuracy: 99.5%&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/pakko/article/details/37878837&quot;&gt;逻辑回归&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cs229.stanford.edu/notes/cs229-notes1.pdf&quot;&gt;CS229 Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/ufdl-logistic-regression.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/ufdl-logistic-regression.html</guid>

      
      <category>UFLDL</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>Markdown</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;p&gt;Markdown 是 HTML 的父集，所以任何 HTML 文件都是有效的 Markdown。这意味着我们可以在 Markdown 里使用任何 HTML 元素，比如注释元素，且不会被 Markdown 解析器所影响。在不同的解析器中，Markdown 的实现方法有所不同。此教程会指出当某功能是否通用及是否只对某一解析器有效。比如，如果你想了解 Github 的解析器语法，可以产科&lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Here-Cheatsheet&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 标头&lt;/h2&gt;

&lt;h1 id=&quot;h1&quot;&gt;这是一个 &amp;lt;h1&amp;gt;&lt;/h1&gt;

&lt;h2 id=&quot;h2&quot;&gt;这是一个 &amp;lt;h2&amp;gt;&lt;/h2&gt;

&lt;h3 id=&quot;h3&quot;&gt;这是一个 &amp;lt;h3&amp;gt;&lt;/h3&gt;

&lt;h4 id=&quot;h4&quot;&gt;这是一个 &amp;lt;h4&amp;gt;&lt;/h4&gt;

&lt;h5 id=&quot;h5&quot;&gt;这是一个 &amp;lt;h5&amp;gt;&lt;/h5&gt;

&lt;h6 id=&quot;h6&quot;&gt;这是一个 &amp;lt;h6&amp;gt;&lt;/h6&gt;

&lt;h1 id=&quot;h1-1&quot;&gt;这是一个 h1&lt;/h1&gt;

&lt;h2 id=&quot;h2-1&quot;&gt;这是一个 h2&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 这是一个 &amp;lt;h1&amp;gt;
## 这是一个 &amp;lt;h2&amp;gt;
### 这是一个 &amp;lt;h3&amp;gt;
#### 这是一个 &amp;lt;h4&amp;gt;
##### 这是一个 &amp;lt;h5&amp;gt;
###### 这是一个 &amp;lt;h6&amp;gt;

对于 &amp;lt;h1&amp;gt; 和 &amp;lt;h2&amp;gt; 元素，Markdown 额外提供了两种添加方式。

这是一个 h1
=============

这是一个 h2
-------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 简易文本样式&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;文本的斜体，粗体，和删除线&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;此文本为斜体。&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;此文本也是。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;此文本为粗体。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;此文本也是&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;此文本是斜体加粗体。&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;或者这样。&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&lt;strong&gt;这个也是！&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*此文本为斜体。*
_此文本也是。_

**此文本为粗体。**
__此文本也是__

***此文本是斜体加粗体。***
**_或者这样。_**
*__这个也是！__*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;段落&lt;/h3&gt;

&lt;p&gt;单个段落由一句或多句邻近的句子组成，这些句子由一个或多个空格分隔。&lt;/p&gt;

&lt;p&gt;这是第一段落. 这句话在同一个段落里，好玩么？&lt;/p&gt;

&lt;p&gt;现在我是第二段落。&lt;br /&gt;
这句话也在第二段落！&lt;/p&gt;

&lt;p&gt;这句话在第三段落！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是第一段落. 这句话在同一个段落里，好玩么？

现在我是第二段落。
这句话也在第二段落！

这句话在第三段落！
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 段落引用可由 &gt; 字符轻松实现。--&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个段落引用. 你可以&lt;br /&gt;
手动断开你的句子，然后在每句句子前面添加 “&amp;gt;” 字符。或者让你的句子变得很长，以至于他们自动得断开。&lt;br /&gt;
只要你的文字以“&amp;gt;” 字符开头，两种方式无异。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 这是一个段落引用. 你可以
&amp;gt; 手动断开你的句子，然后在每句句子前面添加 “&amp;gt;” 字符。或者让你的句子变得很长，以至于他们自动得断开。
&amp;gt; 只要你的文字以“&amp;gt;” 字符开头，两种方式无异。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 序列&lt;/h2&gt;

&lt;!-- 无序序列可由星号，加号或者减号来建立 --&gt;

&lt;ul&gt;
  &lt;li&gt;项目&lt;/li&gt;
  &lt;li&gt;项目&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个项目&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  * 项目
  * 项目
  * 另一个项目
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目&lt;/li&gt;
  &lt;li&gt;项目&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个项目&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  + 项目
  + 项目
  + 另一个项目
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者 &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目&lt;/li&gt;
  &lt;li&gt;项目&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后一个项目&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  - 项目
  - 项目
  - 最后一个项目
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 有序序列可由数字加点来实现 --&gt;

&lt;ol&gt;
  &lt;li&gt;项目一&lt;/li&gt;
  &lt;li&gt;项目二&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;项目三&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 1. 项目一
 2. 项目二
 3. 项目三
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;!-- 即使你的标签数字有误，Markdown 依旧会呈现出正确的序号，
不过这并不是一个好主意--&gt;

&lt;ol&gt;
  &lt;li&gt;项目一&lt;/li&gt;
  &lt;li&gt;项目二&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;项目三&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 1. 项目一
 1. 项目二
 1. 项目三
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;!-- 你也可以使用子序列 --&gt;

&lt;ol&gt;
  &lt;li&gt;项目一&lt;/li&gt;
  &lt;li&gt;项目二&lt;/li&gt;
  &lt;li&gt;项目三
    &lt;ul&gt;
      &lt;li&gt;子项目&lt;/li&gt;
      &lt;li&gt;子项目&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;项目四&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 1. 项目一
 2. 项目二
 3. 项目三
     * 子项目
     * 子项目
 4. 项目四
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;x04-&quot;&gt;0x04 代码段落&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;代码段落&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;This is code
So is this
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 在你的代码中，你仍然使用tab可以进行缩进操作 --&gt;

&lt;pre&gt;&lt;code&gt;my_array.each do |item|
    puts item
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;内联代码可由反引号 ` 实现&lt;/h3&gt;

&lt;p&gt;John 甚至不知道 &lt;code&gt;go_to()&lt;/code&gt; 方程是干嘛的!&lt;/p&gt;

&lt;h3 id=&quot;x05-&quot;&gt;0x05 水平线&lt;/h3&gt;

&lt;p&gt;水平线可由三个或以上的星号或者减号创建，可带可不带空格。&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;***
---
- - - 
****************
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x06-&quot;&gt;0x06 链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://test.com/&quot;&gt;点我点我!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[点我点我!](http://test.com/)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 你也可以为链接加入一个标题：在括弧内使用引号 --&gt;

&lt;p&gt;&lt;a href=&quot;http://test.com/&quot; title=&quot;连接到Test.com&quot;&gt;点我点我!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[点我点我!](http://test.com/ &quot;连接到Test.com&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 相对路径也可以有 --&gt;

&lt;p&gt;&lt;a href=&quot;/music/&quot;&gt;去 music&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[去 music](/music/).
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- Markdown同样支持引用样式的链接 --&gt;

&lt;p&gt;&lt;a href=&quot;http://test.com/&quot; title=&quot;Cool!&quot;&gt;点此链接&lt;/a&gt;以获取更多信息！&lt;br /&gt;
&lt;a href=&quot;http://foobar.biz/&quot; title=&quot;Alright!&quot;&gt;看一看这个链接&lt;/a&gt; 如果你愿意的话.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[点此链接][link1]以获取更多信息！
[看一看这个链接][foobar] 如果你愿意的话.

[link1]: http://test.com/ &quot;Cool!&quot;
[foobar]: http://foobar.biz/ &quot;Alright!&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接的标题可以处于单引号中，括弧中或是被忽略。引用名可以在文档的任意何处，并且可以随意命名，只要名称不重复。&lt;/p&gt;

&lt;h2 id=&quot;x07-&quot;&gt;0x07 图像&lt;/h2&gt;

&lt;p&gt;图像与链接相似，只需在前添加一个感叹号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://imgur.com/myimage.jpg&quot; alt=&quot;这是我图像的悬停文本(alt text)&quot; title=&quot;可选命名&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![这是我图像的悬停文本(alt text)](http://imgur.com/myimage.jpg &quot;可选命名&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 引用样式也同样起作用 --&gt;

&lt;p&gt;![这是我的悬停文本.][myimage]&lt;br /&gt;
[myimage]: relative/urls/cool/image.jpg “在此输入标题”&lt;/p&gt;

&lt;p&gt;![这是我的悬停文本.][myimage]&lt;br /&gt;
[myimage]: relative/urls/cool/image.jpg “在此输入标题”&lt;/p&gt;

&lt;h2 id=&quot;x08-&quot;&gt;0x08 杂项&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;自动链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://testwebsite.com/&quot;&gt;http://testwebsite.com/&lt;/a&gt; 与&lt;br /&gt;
&lt;a href=&quot;http://testwebsite.com/&quot;&gt;http://testwebsite.com/&lt;/a&gt; 等同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;http://testwebsite.com/&amp;gt; 与 [http://testwebsite.com/](http://testwebsite.com/) 等同
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;电子邮件的自动链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#111;&amp;#064;&amp;#098;&amp;#097;&amp;#114;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;&amp;#102;&amp;#111;&amp;#111;&amp;#064;&amp;#098;&amp;#097;&amp;#114;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;foo@bar.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;转义字符&lt;/h3&gt;

&lt;p&gt;我希望 &lt;em&gt;将这段文字置于星号之间&lt;/em&gt; 但是我不希望它被斜体化, 所以我就: *这段置文字于星号之间*。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我希望 *将这段文字置于星号之间* 但是我不希望它被斜体化, 所以我就: \*这段置文字于星号之间\*。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x09-&quot;&gt;0x09 表格&lt;/h2&gt;

&lt;p&gt;表格只被 Github 的 Markdown 支持，并且有一点笨重，但如果你真的要用的话。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;第一列&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;第二列&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;第三列&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;左对齐&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;居个中&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;右对齐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;某某某&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;某某某&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;某某某&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;| 第一列        | 第二列    | 第三列       |
| :----------   | :------:  | ----------:  |
| 左对齐        | 居个中    | 右对齐       |
| 某某某        | 某某某    | 某某某       |
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 或者, 同样的 --&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;第一列&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;第二列&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;第三列&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;这太丑了&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;药不能&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;停&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;第一列 | 第二列 | 第三列
:-- | :-: | --:
这太丑了 | 药不能 | 停
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x10-&quot;&gt;0x10 注释&lt;/h2&gt;

&lt;!-- 如果你插入一个 HTML中的&lt;br /&gt;标签，你可以在段末加入两个以上的空格，
然后另起一段。--&gt;

&lt;!-- 注释。--&gt;

&lt;h2 id=&quot;x11-&quot;&gt;0x11 参考文献&lt;/h2&gt;

</description>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/resources-markdown.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/resources-markdown.html</guid>

      
      <category>Blog</category>
      

      
      <category>资源</category>
      
      
    </item>
  
    <item>
      <title>MathJax and Jekyll</title>
      <description>&lt;h2 id=&quot;x01-mathjax-&quot;&gt;0x01 MathJax 的安装&lt;/h2&gt;

&lt;p&gt;在网页中添加如下内容：（我是直接在 footer.html 中加入）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;
src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-mathjax-&quot;&gt;0x02 MathJax 使用&lt;/h2&gt;

&lt;p&gt;行内公司如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$$E=mc^2$$ is a inline formula.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;E=mc^2&lt;/script&gt; is a inline formula.&lt;/p&gt;

&lt;p&gt;单行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$$ 
\begin{aligned} \dot{x} &amp;amp;= \sigma(y-x) \\ 
\dot{y} &amp;amp;= \rho x - y - xz \\ 
\dot{z} &amp;amp;= -\beta z + xy \end{aligned} 
$$
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
 
\begin{aligned} \dot{x} &amp;= \sigma(y-x) \\ 
\dot{y} &amp;= \rho x - y - xz \\ 
\dot{z} &amp;= -\beta z + xy \end{aligned} 
 %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;x03--ajax-&quot;&gt;0x03 无法使用 Ajax 加载页面&lt;/h2&gt;

&lt;p&gt;由于 Blog 使用了 Ajax 加载页面， MathJax 的公式无法显示，必须重新刷新后，才能显示出来。&lt;/p&gt;

&lt;h2 id=&quot;x04-&quot;&gt;0x04 参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.mathjax.org/en/latest/start.html&quot;&gt;MathJax&lt;/a&gt;&lt;/p&gt;
</description>
      <pubDate>Mon, 09 Mar 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/tech-mathjax-and-jekyll.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/tech-mathjax-and-jekyll.html</guid>

      
      <category>Blog</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>Linear Regression</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;p&gt;在统计学中，线性回归是利用最小二乘函数对自变量和因变量之间进行回归建模。线性回归有很多种，主要分为线性回归和非线性回归。在广义线性模型中，依据因变量的不同可以分为很多类，比如：如果因变量是连续的，就是多重线性回归、如果是二项分布，就是 Logistic 回归、如果是 Poisson 分布，就是 Poisson 分布等。&lt;/p&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 问题的形式化定义&lt;/h2&gt;

&lt;p&gt;在看这篇之前，应该先去复习一下 Ng 在 &lt;a href=&quot;coursera.org&quot;&gt;courses&lt;/a&gt; 上的课程。本文将讲述如何实现线性回归，大致思想是获得目标函数，计算梯度和优化参数。这三个基本步骤，基本上是很多优秀算法的基本内容。&lt;/p&gt;

&lt;p&gt;本文所使用的实例是对房型进行回归预测，当然这个模型是简化了的房价预测模型，而不是现实生活中的例子。&lt;/p&gt;

&lt;p&gt;损失函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Gallery/2015/linear-cost-function.jpg&quot; alt=&quot;Linear cost Function&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i = (1 : size(X, 2))
     temp = theta&#39; * X(1 : size(X, 1), i);
     temp = (temp - y(i)) ^ 2;
     f = f + temp;
end
f = f / 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;梯度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i = (1 : size(X, 2))
    for j = (1 : size(g, 1)) 
        g(j) = g(j) + X(j, i) * (theta&#39; * X(1 : size(X, 1), i) - y(i));
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向量化实现能充分利用计算优势，所以在 R 和 Matlab 中都不提倡用 for 来计算矩阵。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g = X * ((theta&#39; * X) - y)&#39;;

temptheta = repmat(theta, 1, size(theta, 1));
tempy = repmat(y, size(theta, 1), 1);
epsilon = 10 ^ -4;
threshold = 10 ^ -3;
epsilonm = epsilon * eye(size(theta, 1));
theta1 = temptheta + epsilonm;
theta2 = temptheta - epsilonm;
f1 = (theta1&#39; * X - tempy) .^ 2;
f1 = 0.5 * sum(f1, 2);
f2 = (theta2&#39; * X - tempy) .^ 2;
f2 = 0.5 * sum(f2, 2);
tempg = (f1 - f2) ./ (2 * epsilon);
g;
tempg = abs((tempg - g) ./ g);
if any(tempg &amp;gt; threshold)
    fprintf(&#39;\n\n\ngradient is not correct.............................................................\n\n\n&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 实验结果&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Gallery/2015/linear-regression.jpg&quot; alt=&quot;linear regression&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://cs229.stanford.edu/notes/cs229-notes1.pdf&quot;&gt;Lecture Note&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;x04-&quot;&gt;0x04 单词表&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Fourier Series&lt;/td&gt;
      &lt;td&gt;傅立叶级数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;normal equations&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;regularization parameter&lt;/td&gt;
      &lt;td&gt;惩罚系数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hession&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Backpropagation Algorithm&lt;/td&gt;
      &lt;td&gt;反向传播算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(batch) gradient descent&lt;/td&gt;
      &lt;td&gt;（批量）梯度下降法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(overall) cost function&lt;/td&gt;
      &lt;td&gt;（整体）代价函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;squared-error&lt;/td&gt;
      &lt;td&gt;方差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;average sum-of-squares error&lt;/td&gt;
      &lt;td&gt;均方差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;regularization term&lt;/td&gt;
      &lt;td&gt;规则化项&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;weight decay&lt;/td&gt;
      &lt;td&gt;权重衰减&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bias terms&lt;/td&gt;
      &lt;td&gt;偏置项&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bayesian regularization method&lt;/td&gt;
      &lt;td&gt;贝叶斯规则化方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Gaussian prior&lt;/td&gt;
      &lt;td&gt;高斯先验概率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MAP&lt;/td&gt;
      &lt;td&gt;极大后验估计&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;maximum likelihood estimation&lt;/td&gt;
      &lt;td&gt;极大似然估计&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;activation function&lt;/td&gt;
      &lt;td&gt;激活函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tanh function&lt;/td&gt;
      &lt;td&gt;双曲正切函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;non-convex function&lt;/td&gt;
      &lt;td&gt;非凸函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hidden (layer) units&lt;/td&gt;
      &lt;td&gt;隐藏层单元&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;symmetry breaking&lt;/td&gt;
      &lt;td&gt;对称失效&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;learning rate&lt;/td&gt;
      &lt;td&gt;学习速率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;forward pass&lt;/td&gt;
      &lt;td&gt;前向传导&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hypothesis&lt;/td&gt;
      &lt;td&gt;假设值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;error term&lt;/td&gt;
      &lt;td&gt;残差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;weighted average&lt;/td&gt;
      &lt;td&gt;加权平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;feedforward pass&lt;/td&gt;
      &lt;td&gt;前馈传导&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hadamard product&lt;/td&gt;
      &lt;td&gt;阿达马乘积&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;forward propagation&lt;/td&gt;
      &lt;td&gt;前向传播&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vectorization&lt;/td&gt;
      &lt;td&gt;矢量化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;intercept term&lt;/td&gt;
      &lt;td&gt;截距&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;the log likelihood&lt;/td&gt;
      &lt;td&gt;对数似然函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;derivative&lt;/td&gt;
      &lt;td&gt;导函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;trivial answer&lt;/td&gt;
      &lt;td&gt;平凡解&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;norm constrained&lt;/td&gt;
      &lt;td&gt;范数约束&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sparse autoencoder&lt;/td&gt;
      &lt;td&gt;稀疏自编码器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;norm bounded&lt;/td&gt;
      &lt;td&gt;有界范数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;numerical roundoff errors&lt;/td&gt;
      &lt;td&gt;数值舍入误差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;significant digits&lt;/td&gt;
      &lt;td&gt;有效数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unrolling&lt;/td&gt;
      &lt;td&gt;组合扩展&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;conjugate gradient&lt;/td&gt;
      &lt;td&gt;共轭梯度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;step-size&lt;/td&gt;
      &lt;td&gt;步长值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hyperbolic tangent&lt;/td&gt;
      &lt;td&gt;双曲正切函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;normalization&lt;/td&gt;
      &lt;td&gt;归一化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eigenvector&lt;/td&gt;
      &lt;td&gt;特征向量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;eigenvalue&lt;/td&gt;
      &lt;td&gt;特征值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;magnitude&lt;/td&gt;
      &lt;td&gt;幅值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;decorrelation&lt;/td&gt;
      &lt;td&gt;去相关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;zero-mean&lt;/td&gt;
      &lt;td&gt;均值为零&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;symmetric positive semi-definite matrix&lt;/td&gt;
      &lt;td&gt;对称半正定矩阵&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;numerically reliable&lt;/td&gt;
      &lt;td&gt;数值计算上稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sorted in decreasing order&lt;/td&gt;
      &lt;td&gt;降序排列&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;singular value&lt;/td&gt;
      &lt;td&gt;奇异值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;singular vector&lt;/td&gt;
      &lt;td&gt;奇异向量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vectorized implementation&lt;/td&gt;
      &lt;td&gt;向量化实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;diagonal&lt;/td&gt;
      &lt;td&gt;对角线&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;class labels&lt;/td&gt;
      &lt;td&gt;类型标记&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hypothesis&lt;/td&gt;
      &lt;td&gt;估值函数/估计值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fine-tune&lt;/td&gt;
      &lt;td&gt;微调&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pre-training&lt;/td&gt;
      &lt;td&gt;预训练&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;represent compactly&lt;/td&gt;
      &lt;td&gt;简洁地表达&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;part-whole decompositions&lt;/td&gt;
      &lt;td&gt;“部分-整体”的分解&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;parts of objects&lt;/td&gt;
      &lt;td&gt;目标的部件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;highly non-convex optimization problem&lt;/td&gt;
      &lt;td&gt;高度非凸的优化问题&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;conjugate gradient&lt;/td&gt;
      &lt;td&gt;共轭梯度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;diffusion of gradients&lt;/td&gt;
      &lt;td&gt;梯度的弥散&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Greedy layer-wise training&lt;/td&gt;
      &lt;td&gt;逐层贪婪训练方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hierarchical grouping&lt;/td&gt;
      &lt;td&gt;层次型分组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Higher-order features&lt;/td&gt;
      &lt;td&gt;更高阶特征&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stacked autoencoder&lt;/td&gt;
      &lt;td&gt;栈式自编码神经网络\多层自动编码机\多层自动编码神经网络&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DC component&lt;/td&gt;
      &lt;td&gt;直流分量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;local mean subtraction&lt;/td&gt;
      &lt;td&gt;局部均值消减&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rescaling&lt;/td&gt;
      &lt;td&gt;缩放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;per-example mean subtraction&lt;/td&gt;
      &lt;td&gt;逐样本均值消减&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MFCC&lt;/td&gt;
      &lt;td&gt;Mel倒频系数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;zero-mean&lt;/td&gt;
      &lt;td&gt;零均值化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;low-pass filtering&lt;/td&gt;
      &lt;td&gt;低通滤波&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;reconstruction based models&lt;/td&gt;
      &lt;td&gt;基于重构的模型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;orthogonalization&lt;/td&gt;
      &lt;td&gt;正交化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Independent Component Analysis&lt;/td&gt;
      &lt;td&gt;独立成分分析&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Over-complete basis&lt;/td&gt;
      &lt;td&gt;超完备基&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Orthonormal basis&lt;/td&gt;
      &lt;td&gt;标准正交基&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Sparsity penalty&lt;/td&gt;
      &lt;td&gt;稀疏惩罚项&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Under-complete basis&lt;/td&gt;
      &lt;td&gt;不完备基&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Line-search algorithm&lt;/td&gt;
      &lt;td&gt;线搜索算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Topographic cost term&lt;/td&gt;
      &lt;td&gt;拓扑代价项&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;degeneracy&lt;/td&gt;
      &lt;td&gt;退化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;generative model&lt;/td&gt;
      &lt;td&gt;生成模型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;linear superposition&lt;/td&gt;
      &lt;td&gt;线性叠加&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;additive noise&lt;/td&gt;
      &lt;td&gt;加性噪声&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;the empirical distribution&lt;/td&gt;
      &lt;td&gt;经验分布函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;KL divergence&lt;/td&gt;
      &lt;td&gt;KL 散度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Gaussian white noise&lt;/td&gt;
      &lt;td&gt;高斯白噪音&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;the prior distribution&lt;/td&gt;
      &lt;td&gt;先验分布&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;prior probability&lt;/td&gt;
      &lt;td&gt;先验概率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;the energy function&lt;/td&gt;
      &lt;td&gt;能量函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;least squares&lt;/td&gt;
      &lt;td&gt;最小二乘法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;convex optimization software&lt;/td&gt;
      &lt;td&gt;凸优化软件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;quadratic constraints&lt;/td&gt;
      &lt;td&gt;二次约束&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;the Lagrange dual&lt;/td&gt;
      &lt;td&gt;拉格朗日对偶函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;feedforward architectures&lt;/td&gt;
      &lt;td&gt;前馈结构算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Full Connected Networks&lt;/td&gt;
      &lt;td&gt;全联通网络&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Locally Connected Networks&lt;/td&gt;
      &lt;td&gt;部分联通网络&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Contiguous Groups&lt;/td&gt;
      &lt;td&gt;连接区域&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Visual Cortex&lt;/td&gt;
      &lt;td&gt;视觉皮层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;over-fitting&lt;/td&gt;
      &lt;td&gt;过拟合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;translation invariant&lt;/td&gt;
      &lt;td&gt;平移不变性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;object detection&lt;/td&gt;
      &lt;td&gt;物体检测&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;linear activation function&lt;/td&gt;
      &lt;td&gt;线性激励函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;identity activation function&lt;/td&gt;
      &lt;td&gt;恒等激励函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sparsity cost&lt;/td&gt;
      &lt;td&gt;稀疏代价&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;non-convex&lt;/td&gt;
      &lt;td&gt;非凸的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;weight decay&lt;/td&gt;
      &lt;td&gt;权重衰变&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topographic sparse coding&lt;/td&gt;
      &lt;td&gt;拓扑稀疏编码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topographically ordered&lt;/td&gt;
      &lt;td&gt;拓扑秩序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;smoothed L1 penalty&lt;/td&gt;
      &lt;td&gt;平滑的一范数惩罚&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mini-batches&lt;/td&gt;
      &lt;td&gt;迷你块&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;the rate of convergence&lt;/td&gt;
      &lt;td&gt;收敛速度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;local optima&lt;/td&gt;
      &lt;td&gt;局部最优解&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;weight matrix&lt;/td&gt;
      &lt;td&gt;权重矩阵&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;square function&lt;/td&gt;
      &lt;td&gt;平方函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Confidence Interval&lt;/td&gt;
      &lt;td&gt;置信区间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;differentiable function&lt;/td&gt;
      &lt;td&gt;可微方程&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
      <pubDate>Sat, 07 Mar 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/ufldl-linear-regression.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/ufldl-linear-regression.html</guid>

      
      <category>UFLDL</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>Maven</title>
      <description>&lt;h2 id=&quot;x01-centos--openjdk&quot;&gt;0x01 CentOS 卸载 OpenJDK&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;yum list installed |grep java
yum -y remove java-1.7.0-openjdk*
yum -y remove tzdata-java.noarch
yum -y list java*
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-centos--maven&quot;&gt;0x02 CentOS 安装 Maven&lt;/h2&gt;

&lt;p&gt;OpenJDK 的安装目录和 Oracle JDK的安装目录不一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export M2_HOME=/usr/local/apache-maven/apache-maven-3.2.5
export MAVEN_OPTS=&quot;-Xms256m -Xmx512m&quot;
M2=$M2_HOME/bin
PATH=$M2:$PATH
export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71.x86_64/jre/
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin

source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x03--maven-&quot;&gt;0x03 修改 Maven 的库地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;${user.home}/.m2/settings.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x04-maven-phases&quot;&gt;0x04 Maven Phases&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mvn validate：      验证工程是否正确，所有需要的资源是否可用。 
mvn compile：       编译项目的源代码。   
mvn test：          使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。 
mvn Package：       把已编译的代码打包成可发布的格式，比如jar。 
mvn integration-test： 如有需要，将包处理和发布到一个能够进行集成测试的环境。 
mvn verify：        运行所有检查，验证包是否有效且达到质量标准。 
mvn install：       把包安装在本地的repository中，可以被其他工程作为依赖来使用。 
mvn Deploy：        在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 
mvn clean：         清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。 
mvn site：          为项目生成文档站点。 
mvn idea:idea       提供 IntelliJ IDEA 工程支持
mvn eclipse:eclipse 提供 Eclipse IDE 工程支持
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phases 和 goals 可以按顺序执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn clean dependency:copy-dependencies package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条命令会先清理项目，然后复制依赖，最后执行 package Phases	&lt;/p&gt;

&lt;h2 id=&quot;x05-standard-directory-layout&quot;&gt;0x05 Standard Directory Layout&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;src/main/java       Application/Library sources
src/main/resources	Application/Library resources
src/main/filters	Resource filter files
src/main/config     Configuration files
src/main/scripts	Application/Library scripts
src/main/webapp  	Web application sources
src/test/java       Test sources
src/test/resources	Test resources
src/test/filters	Test resource filter files
src/it              Integration Tests (primarily for plugins)
src/assembly        Assembly descriptors
src/site	        Site
LICENSE.txt	        Project&#39;s license
NOTICE.txt	        Notices and attributions required by libraries that the project depends on
README.txt	        Project&#39;s readme
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Wed, 07 Jan 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/tools-maven.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/tools-maven.html</guid>

      
      <category>Tool</category>
      

      
      <category>工具</category>
      
      
    </item>
  
    <item>
      <title>核电站问题</title>
      <description>&lt;h2 id=&quot;x01-&quot;&gt;0x01 核电站问题&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;问题描述&lt;/h3&gt;

&lt;p&gt;一个核电站有N个放核物质的坑，坑排列在一条直线上。如果连续3个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。现在，请你计算：对于给定的N，求不发生爆炸的放置核物质的方案总数。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;输入数据&lt;/h3&gt;

&lt;p&gt;输入文件有多行，每行对应一个正整数 N &amp;lt;= 40;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;输出要求&lt;/h3&gt;

&lt;p&gt;输出文件有多行，每行只有一个正整数，表示方案总数。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;输入样例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1
2
3
4
10
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;输出样例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;2
4
7
13
504
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 解题思路&lt;/h2&gt;

&lt;p&gt;用动态规划。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;状态转移方程：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;f[i] = 2 * f[i - 1] - f[i - 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt; 
using namespace std;
unsigned long long f[60] = { 0 };
int main()
{
	int i = 2, n;
	f[0] = f[1] = 1;
	while (cin &amp;gt;&amp;gt; n)
	{
		if (0 != f[n + 1]) cout &amp;lt;&amp;lt; f[n + 1];
		else {
			for (; i &amp;lt; n + 2; i++)
			{
				f[i] = 2 * f[i - 1] - f[i - 4];
			}
			cout &amp;lt;&amp;lt; f[n + 1] &amp;lt;&amp;lt; endl;
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2015/algorithms-he-dian-zhan-wen-ti.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2015/algorithms-he-dian-zhan-wen-ti.html</guid>

      
      <category>Algorithms</category>
      

      
      <category>解题</category>
      
      
    </item>
  
    <item>
      <title>Vagrant</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vagrant是一个基于Ruby的管理工具，常用于搭建和配置轻量级的、可再生的和便携式的开发或测试环境，可以使用这种方法搭建跨平台开发环境。它只是一种工具，如果你觉得开发时并不好，那么你只能简化你自己的工作流。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 安装&lt;/h2&gt;

&lt;h3 id=&quot;vagrant&quot;&gt;安装Vagrant&lt;/h3&gt;

&lt;p&gt;choco install vagrant&lt;/p&gt;

&lt;h3 id=&quot;virtualbox&quot;&gt;安装Virtualbox&lt;/h3&gt;

&lt;p&gt;choco install virtualbox&lt;br /&gt;
choco install virtualbox.extensionpack&lt;/p&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 使用&lt;/h2&gt;

&lt;h3 id=&quot;box&quot;&gt;下载启动Box&lt;/h3&gt;
&lt;p&gt;在Vagrant中，box是一种打包好的镜像，通过这个镜像，可以生成相应的虚拟机。box可以通过&lt;a href=&quot;http://www.vagrantbox.es/&quot;&gt;官方网站&lt;/a&gt;下载，也可以自己制作，在团队内分享。&lt;/p&gt;

&lt;p&gt;官方的Box可以在创建时自动下载。例如以下步骤：进入一个vagrant虚拟机目录，一个目录管理一个虚拟机.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant init hashicorp/precise32 # 创建一个ubuntu的虚拟机
vagrant up # 启动这个虚拟机
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个步骤，vagrant会去box列表中找&lt;code&gt;hashicorp/precise32&lt;/code&gt;这个镜像，如果没有就去官方下载。Box被保存在&lt;code&gt;~/.vagrant&lt;/code&gt;下。通过命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant box list 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以查看已经下载的box。如果想以这个box再建立一个虚拟机，只要再创建一个目录，例如&lt;code&gt;~/Documents/Vagrant/Ubuntu32&lt;/code&gt;，然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant init hashicorp/precise32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;

&lt;p&gt;如果直接离线下载好了 box 文件，可以通过以下命令添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vagrant box add OpenSOC .\centos65-x86_64-20140116.box
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样添加后，可以把你下载的 box 包删除了。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;操作虚拟机&lt;/h3&gt;

&lt;p&gt;操作虚拟机时，必须进入刚刚建立的目录中去，这个目录中必须含有&lt;code&gt;init&lt;/code&gt;命令建立的Vagrantfile文件。常用命令有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant init       # 初始化
$ vagrant up         # 启动虚拟机
$ vagrant halt       # 关闭虚拟机
$ vagrant reload     # 重启虚拟机
$ vagrant ssh        # SSH 至虚拟机
$ vagrant status     # 查看虚拟机运行状态
$ vagrant destroy    # 销毁当前虚拟机
$ vagrant box add
$ vagrant box list
$ vagrant box remove
$ vagrant box repackage
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;共享文件夹&lt;/h3&gt;
&lt;p&gt;通过Vagrant建立的虚拟机和Mac共享文件非常容易，虚拟机中&lt;code&gt;/vagrant&lt;/code&gt;目录会映射到我们本地虚拟机目录中。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/Documents/Vagrant/Ubuntu
vagrant up
vagrant ssh
cd /vagrant
ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，我们会看到，这里显示的文件和&lt;code&gt;~/Documents/Vagrant/Ubuntu&lt;/code&gt;下是一样的。&lt;/p&gt;

&lt;h3 id=&quot;box-1&quot;&gt;共享Box&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;vagrant package --base my-virtual-machine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以可以将一个虚拟机打包成Box，供别人使用。别人只要用打包的box来创建一个虚拟机即可。&lt;/p&gt;

&lt;h2 id=&quot;x03-vagrantfile&quot;&gt;0x03 Vagrantfile&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;网络配置&lt;/h3&gt;

&lt;p&gt;全网访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.vm.network :forwarded_port, guest: 80, host: 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私有模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.vm.network :private_network, ip: &quot;192.168.1.104&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;局域网&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.vm.network :public_network
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;目录映射&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;config.vm.synced_folder &quot;wwwroot/&quot;, &quot;/var/www&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以在 Vagrantfile 中配置自己要执行的文件，配置虚拟机内存大小。&lt;/p&gt;

&lt;h2 id=&quot;x04-&quot;&gt;0x04 参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.vagrantup.com/v2/&quot;&gt;Vagrant Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.segmentfault.com/fenbox/1190000000264347&quot;&gt;使用 Vagrant 打造跨平台开发环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.smdcn.net/article/1308.html&quot;&gt;使用Vagrant在Windows下部署开发环境&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
      <pubDate>Sat, 27 Dec 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tools-vagrant.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tools-vagrant.html</guid>

      
      <category>Tool</category>
      

      
      <category>工具</category>
      
      
    </item>
  
    <item>
      <title>OpenSOC</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;思科在BroCON大会上开源了其安全大数据分析架构OpenSOC。OpenSOC是一个针对网络包和流的大数据分析框架，它是大数据分析与安全分析技术的结合, 能够实时的检测网络异常情况并且可以扩展很多节点，它的存储使用开源项目Hadoop，实时索引使用开源项目ElasticSearch，在线流分析使用著名的开源项目Storm。开源时还没到稳定版，所以对于个人用户来说不是很友好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-opensoc-&quot;&gt;0x01 OpenSoc 的组成&lt;/h2&gt;

&lt;p&gt;OpenSOC 是 cisco 公司的一个开源项目，bro 项目中包含 OpenSOC ，所以应该 bro 项目是 OpenSOC 的一个封装。&lt;/p&gt;

&lt;p&gt;2 Network Capture Cards (Recommend Napatech NT20E2-CAP)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;component&lt;/th&gt;
      &lt;th&gt;function&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Apache Flume 1.4.0 +&lt;/td&gt;
      &lt;td&gt;Telemetry Capture Layer&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Apache Kafka 0.8.1+&lt;/td&gt;
      &lt;td&gt;Data Bus&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Apache Storm 0.9 +&lt;/td&gt;
      &lt;td&gt;Stream Processor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Apache Hadoop 2.x (any distribution)&lt;/td&gt;
      &lt;td&gt;Cloud Platform&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Apache Hive 12 + (13 recommended)&lt;/td&gt;
      &lt;td&gt;Long-Term Data Store&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Apache Hbase 0.94+&lt;/td&gt;
      &lt;td&gt;Long-Term Packet Store&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Elastic Search 1.1 +&lt;/td&gt;
      &lt;td&gt;Real-Time Index and Search&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MySQL 5.6+&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Kibana&lt;/td&gt;
      &lt;td&gt;Visualization Platform&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;mysql、kibana、elastic search、opensoc&lt;/p&gt;

&lt;p&gt;OpenSOC-Streaming&lt;br /&gt;
OpenSOC-Aggregation&lt;br /&gt;
OpenSOC-ML&lt;/p&gt;

&lt;h2 id=&quot;x02-survey-of-algorithms-used-by-opensoc&quot;&gt;0x02 Survey of Algorithms Used by OpenSOC&lt;/h2&gt;

&lt;h3 id=&quot;offline&quot;&gt;Offline&lt;/h3&gt;

&lt;p&gt;Hypothesis Tests&lt;/p&gt;

&lt;p&gt;Decision Trees/Random Forests&lt;/p&gt;

&lt;p&gt;Association Rules (Apriori)&lt;/p&gt;

&lt;p&gt;BIRCH/DBSCAN Clustering&lt;/p&gt;

&lt;p&gt;Auto Regressive (AR) Moving Average (MA)&lt;/p&gt;

&lt;h3 id=&quot;online&quot;&gt;Online&lt;/h3&gt;

&lt;h4 id=&quot;stream-clustering&quot;&gt;Stream Clustering&lt;/h4&gt;

&lt;p&gt;StreamKM++: computes a small weighted sample of the data stream and it uses the kmeans++ algorithm as a randomized seeding technique to choose the first values for the clusters.&lt;/p&gt;

&lt;p&gt;CluStream: micro-clusters are temporal extensions of cluster feature vectors. The microclusters are stored at snapshots in time following a pyramidal pattern.&lt;/p&gt;

&lt;p&gt;ClusTree: It is a parameter free algorithm automatically adapting to the speed of the stream and it is capable of detecting concept drift, novelty, and outliers in the stream.&lt;/p&gt;

&lt;p&gt;DenStream: uses dense micro-clusters (named core-micro-cluster) to summarize clusters. To maintain and distinguish the potential clusters and outliers, this method presents coremicro-cluster and outlier micro-cluster structures.&lt;/p&gt;

&lt;p&gt;D-Stream: maps each input data record into a grid and it computes the grid density. The grids are clustered based on the density. This algorithm adopts a density decaying technique to capture the dynamic changes of a data stream.&lt;/p&gt;

&lt;p&gt;CobWeb: uses a classification tree. Each node in a classification tree represents a class (concept) and is labeled by a probabilistic concept that summarizes the attribute-value distributions of objects classified under the node&lt;/p&gt;

&lt;h4 id=&quot;stream-classification&quot;&gt;Stream Classification&lt;/h4&gt;

&lt;p&gt;Hoeffding Tree (VFDT)：incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time&lt;/p&gt;

&lt;p&gt;Half-Space Trees：ensemble model that randomly spits data into half spaces. They are created online and detect anomalies by their deviations in placement within the forest relative to other data from the same window&lt;/p&gt;

&lt;h4 id=&quot;outlier-detection&quot;&gt;Outlier Detection&lt;/h4&gt;

&lt;p&gt;Median Absolute Deviation: Telemetry is anomalous if the deviation of its latest datapoint with respect to the median is X times larger than the median of deviations &lt;/p&gt;

&lt;p&gt;Standard Deviation from Average: Telemetry is anomalous if the absolute value of the average of the latest three datapoint minus the moving average is greater than three standard deviations of the average.&lt;/p&gt;

&lt;p&gt;Standard Deviation from Moving Average: Telemetry is anomalous if the absolute value of the average of the latest three datapoints minus the moving average is greater than three standard deviations of the moving average.&lt;/p&gt;

&lt;p&gt;Mean Subtraction Cumulation: Telemetry is anomalous if the value of the next datapoint in the series is farther than three standard deviations out in cumulative terms after subtracting the mean from each data point &lt;/p&gt;

&lt;p&gt;Least Squares: Telemetry is anomalous if the average of the last three datapoints on a projected least squares model is greater than three sigma&lt;/p&gt;

&lt;p&gt;Histogram Bins: Telemetry is anomalous if the average of the last three datapoints falls into a histogram bin with less than x &lt;/p&gt;

&lt;h3 id=&quot;approximation-for-streaming&quot;&gt;Approximation for Streaming&lt;/h3&gt;

&lt;p&gt;Skip Lists&lt;/p&gt;

&lt;p&gt;HyperLogLog&lt;/p&gt;

&lt;p&gt;Bloom Filters&lt;/p&gt;

&lt;p&gt;Sketches&lt;/p&gt;

&lt;p&gt;Digest&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/OpenSOC/opensoc/wiki/CONTRIBUTING.md&quot;&gt;OpenSOC CONTRIBUTING&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/sitemap/index.html&quot;&gt;www.bro.org&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/sphinx-git/index.html&quot;&gt;Bro Manual&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/documentation/index.html&quot;&gt;bro Documentation and Training&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/community/software.html&quot;&gt;Related Software&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/community/traces.html&quot;&gt;bro Packet Traces&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/grutz/bro/blob/master/doc/install/install.rst&quot;&gt;bro Installing Bro&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/documentation/exercises/index.html&quot;&gt;bro Exercises&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.bro.org/research/index.html&quot;&gt;Research&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://try.bro.org/#/trybro&quot;&gt;Try Bro&lt;/a&gt;&lt;/p&gt;
</description>
      <pubDate>Tue, 23 Dec 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/resources-opensoc.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/resources-opensoc.html</guid>

      
      <category>OpenSOC</category>
      

      
      <category>资源</category>
      
      
    </item>
  
    <item>
      <title>CSS</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;各种选择器可以组合使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 基本概念&lt;/h2&gt;

&lt;p&gt;行内元素&lt;span&gt; &lt;/span&gt;，块级元素&amp;lt;div&amp;gt; &amp;lt;/div&amp;gt;。&lt;/p&gt;

&lt;p&gt;CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;selector {declaration1; declaration2; ... declarationN }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果值为若干单词，则要给值加引号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {font-family: &quot;sans serif&quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;层叠次序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;浏览器缺省设置
外部样式表
内部样式表（位于 &amp;lt;head&amp;gt; 标签内部）
内联样式（在 HTML 元素内部）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择器的分组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1,h2,h3,h4,h5,h6 {
  color: green;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继承：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body  {
 font-family: Verdana, sans-serif;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个网页的字体就是 Verdana    &lt;/p&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 选择器&lt;/h2&gt;

&lt;p&gt;id 选择器和类选择器都能用作派生选择器&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;派生选择器（元素选择器，类型选择器）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;li strong {
    font-style: italic;
    font-weight: normal;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;id-&quot;&gt;id 选择器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#red {color:red;}
#green {color:green;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;类选择器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.center {text-align: center}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;属性选择器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[title]
{
color:red;
}	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性和值选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[title=W3School]
{
border:5px solid blue;
}	
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选择器&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性和值的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute~=value]&lt;/td&gt;
      &lt;td&gt;用于选取属性值中包含指定词汇的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute  =value]&lt;/td&gt;
      &lt;td&gt;用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute^=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值开头的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute$=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值结尾的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute*=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值中包含指定值的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;通配符选择器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;* {color:red;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;后代选择器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;h1 em {color:red;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个规则会把作为 h1 元素后代的 em 元素的文本变为 红色。&lt;/p&gt;

&lt;h2 id=&quot;x03-classid&quot;&gt;0x03 class与id&lt;/h2&gt;

&lt;p&gt;class 选择器用来公用，id 选择器用于操作。&lt;/p&gt;

&lt;h2 id=&quot;x04-htmlcss&quot;&gt;0x04 html引用css方法&lt;/h2&gt;

&lt;p&gt;1、直接在div中使用css样式制作div+css网页&lt;br /&gt;
2、html中使用style自带式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt; 
&amp;lt;!-- 
.ceshi {font-size:14px; color:#FF0000;}/*这里是设置CSS的样式内容*/ 
--&amp;gt; 
&amp;lt;/style&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、使用@import引用外部CSS文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt; 
&amp;lt;!-- 
@import url(wcss.css);/*这里是通过@import引用CSS的样式内容*/ 
--&amp;gt; 
&amp;lt;/style&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、使用link引用外部CSS文件（推荐此方法）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;wcss.css&quot; type=&quot;text/css&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x05-examples&quot;&gt;0x05 examples&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#E F{color:red;}          选择 E 元素后所有 F 后代元素           
#E &amp;gt; F{color:red;}       E &amp;gt; F 表示选择E元素的所有子F元素，只选择一代
#E + F{color:inherit;} 相邻兄弟选择器可以选择紧接在另一元素后的元素，而且他们具有一个相同的父元素
#E F:nth-child(2){color:red}	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E+F表示HTML中紧随E的F元素。	&lt;/p&gt;

&lt;p&gt;nth-child是个伪类的用法，如F:nth-child(2)就表示在F的父元素中选择位居第二位的F。&lt;/p&gt;
</description>
      <pubDate>Mon, 22 Dec 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/resources-css.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/resources-css.html</guid>

      
      <category>Web</category>
      

      
      <category>资源</category>
      
      
    </item>
  
    <item>
      <title>Vim</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;本来习惯linux方式，但驱动太差，只能把 Vim 安在Windows上了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01--windows-&quot;&gt;0x01 在 Windows 上如何复制粘贴&lt;/h2&gt;

&lt;p&gt;Windows to vim Shift+Insert, vim to Windows ‘%p&lt;/p&gt;

&lt;p&gt;VIM具有多个剪贴板，并且和系统剪贴板是完全独立的。在 Vim 中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:reg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到之前复制过的所有内容。&lt;/p&gt;
</description>
      <pubDate>Wed, 17 Dec 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tools-vim.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tools-vim.html</guid>

      
      <category>Tool</category>
      

      
      <category>工具</category>
      
      
    </item>
  
    <item>
      <title>Sublime</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;编辑器从 notepad 、notepad +  + 、editplus、UE 到 gedit 。前面的有些要么觉得他功能太简单，要么不符合我的审美。Vim Emacs 在 Linux 系统下磕磕碰碰用了几个月，但周围人都用的 Windows ，传递文件很不方便，回到 Windows 后，不喜欢 Gvim 的 UI，Emacs 启动速度慢，最后试用了 Sublime，觉得很喜欢。但是我还是心中在怀念 Vim 和 Emacs 的快捷键方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 常用的包&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Package Control         包管理工具
Sublime CodeIntel       代码自动提示
SublimeLinter           支持lint语法的插件
SublimeEnhancements
Bracket Highlighter     括号匹配
NodeJs
Smart Markdown          markdow 折叠功能 tab
Markdown Preview
Jekyll
prefixr
Emmet
SublimeHaskell
TAG                     html/css 自动格式化
Terminal
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-build-system&quot;&gt;0x02 Build System&lt;/h2&gt;
&lt;p&gt;可以当作基本的IDE，&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 常用快捷键&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;function&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + K, B  &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;侧边栏开关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + Shift + [ &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;折叠代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt;   Ctrl + Shift + ] &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;展开代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt;   Ctrl + T   &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;添加时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt;   Ctrl + Z  &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;撤销&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt;   Ctrl + Y    &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;恢复撤销&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt;   Ctrl + Shift + P  &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;命令面板&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt;   Ctrl + Alt + P  &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;切换项目&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section&quot;&gt;文件&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;function&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + O&lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;打开文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + Shift + N &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;新建窗口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + ]        &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;缩进&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + L   &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;选择整行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + Shift + K    &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;删除整行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + J        &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;合并行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + Shift + ↑ &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;上行互换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl + /     &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;注释整行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;kbd&gt; Ctrl  +  Shift  +  / &lt;/kbd&gt;&lt;/td&gt;
      &lt;td&gt;块注释开关&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-1&quot;&gt;书签&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;function&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + F2&lt;/td&gt;
      &lt;td&gt;设置书签&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F2&lt;/td&gt;
      &lt;td&gt;下一个书签&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F2&lt;/td&gt;
      &lt;td&gt;上一个书签&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Alt + F2&lt;/td&gt;
      &lt;td&gt;选择所有书签&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F2&lt;/td&gt;
      &lt;td&gt;清除所有书签&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-2&quot;&gt;查找&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;function&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;F3&lt;/td&gt;
      &lt;td&gt;查找下一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shift + F3&lt;/td&gt;
      &lt;td&gt;查找上一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + H&lt;/td&gt;
      &lt;td&gt;替换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + H&lt;/td&gt;
      &lt;td&gt;替换下一个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + Shift + F&lt;/td&gt;
      &lt;td&gt;查询文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + G&lt;/td&gt;
      &lt;td&gt;到达行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ctrl + ,&lt;/td&gt;
      &lt;td&gt;匹配&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;x04-project&quot;&gt;0x04 Project&lt;/h2&gt;

&lt;p&gt;可以将不同的文件组成项目，然后再不同项目之间切换。&lt;/p&gt;

&lt;p&gt;project_name.sublime-project：包含工程定义，该文件会被记录到版本控制中。&lt;/p&gt;

&lt;p&gt;project_name.sublime-workspace：包含用户工程中对文件的操作数据。&lt;/p&gt;

&lt;h2 id=&quot;x05-&quot;&gt;0x05 ?&lt;/h2&gt;

&lt;p&gt;谁还记得没有插件的 Sublime 是什么样子吗？&lt;/p&gt;

</description>
      <pubDate>Wed, 17 Dec 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tools-Sublime.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tools-Sublime.html</guid>

      
      <category>Tool</category>
      

      
      <category>工具</category>
      
      
    </item>
  
    <item>
      <title>Haskell 开发环境</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Haskell 是一种标准化的，通用的纯函数编程语言，有非限定性语义和强静态类型。它的命名源自美国逻辑学家Haskell Brooks Curry，他在数学逻辑方面上的工作使得函数式编程语言有了广泛的基础。这个人很有名，它名字三个词语中有两个字都是计算机科学家绕不过的地方。pandoc 就是 Haskell 写成的，本文是在学习了 Scheme 后，决定学习下 Haskell 是，在 Windows 8.1 环境下的安装记录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01--haskell-platform&quot;&gt;0x01 安装 Haskell Platform&lt;/h2&gt;

&lt;p&gt;去下载 Haskell 安装包。安装完后，进入 CMD ，执行 cabal update，去仓库更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cabal install bytestring aeson haskell-src-exts haddock ghc-mod stylish-haskell
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02--sublimehaskell-&quot;&gt;0x02 安装 SublimeHaskell 插件&lt;/h2&gt;

&lt;p&gt;因为从 Emacs 到使用 Sublime 有一段时间了，正好 Sublime 下有一个 Haskell 开发插件。 CTRL + SHIFT + p，安装 SublimeHaskell 插件。&lt;/p&gt;

&lt;p&gt;安装完后，进入 Preferences -&amp;gt; Package Settings -&amp;gt; SublimeHaskell -&amp;gt; Settings User 输入以下内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;enable_hdevtools&quot;: false,
    &quot;inspect_modules&quot;: false,
    &quot;add_to_PATH&quot;: [ &quot;.../AppData/Roaming/cabal/bin&quot; ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 测试&lt;/h2&gt;

&lt;p&gt;新建一个 .hs 结尾文件，输入“main”并回车，会产生以下文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Main where

main = putStrLn &quot;Hello World &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其中添加 main :: IO () 后 CRTL + b。&lt;/p&gt;

</description>
      <pubDate>Tue, 16 Dec 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tech-how-to-config-haskell-environment.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tech-how-to-config-haskell-environment.html</guid>

      
      <category>Haskell</category>
      
      <category>Setup</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>如何成为一名黑客</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 前言&lt;/h2&gt;

&lt;p&gt;随着安全行业产业化，很多大学生想成为 hacker。由于媒体宣传的影响，在普通大众人心中 hacker 是一个很酷很厉害的认为，但事实上怎么样？只有经历过的人才能知道。我有幸接触过学习过 hacker 技术，个人觉得 hacker 就是使用一些 tips 获得一些他想要的，hacker 本身应该是属于测试行业的，但由于 tips 技能积累的多了，所以需要很多东西要学习，也就诞生了 hacker 这个行当。本文将介绍一些 hacker 技能，以及一些初级的方向。我更愿意称掌握 hacker 技巧的人为：高级测试程序员，而不是黑客。希望大家有幸获得这种 hack 技能后，用于测试程序，而不是给别人带来麻烦。&lt;/p&gt;

&lt;h2 id=&quot;x01--hacker-&quot;&gt;0x01 了解 hacker 历史&lt;/h2&gt;

&lt;p&gt;“不知过去，不知未来”。关于 hacker 的过去有很多人说过，有人记得电子朋克时代？。计算机 hacker 历史，很长很长，他值得任何一名计算机人员去了解。此次我就不再多加讲述，如果有时间以后我可以补充。&lt;/p&gt;

&lt;h2 id=&quot;x02-hacker-&quot;&gt;0x02 hacker 思维&lt;/h2&gt;

&lt;p&gt;hacker 的思维状态是这样：在生活中不论你遇到什么，你都从一个 hacker 的视觉来思考如何才能 hack 它。作为一名 hacker 你需要对任何你能接触事物的好奇心。&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 了解自己的技术技能&lt;/h2&gt;

&lt;p&gt;成为一名 hacker 不是一早一夕的事。它应该是一辈子的爱好。当你遇到新的场景的时候，你需要知道你还缺少哪一块知识，知道如何去学习，所以你需要感知本人的知识状态。&lt;/p&gt;

&lt;h2 id=&quot;x04--it-&quot;&gt;0x04 必备 IT 技能&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  · 学习如何安装 Windows、Linux、BSD 和 MAC OS
  · 学习网络概念
  · 了解基本网络设备
  · 知道网络协议
  · 自学能力
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上这些只是最小的技能，是理解 hack tips 的基础。通过这些点你可以去获得关于整个计算机的知识。自学能力是最重要的，因为 hack 行业还有细分，比如 Web hacker、hardware hacker、mobile hacker、逆向、电子取证等。你可能需要学习 Android 设备，云计算环境，根据你的目标特性的不同。&lt;/p&gt;

&lt;h2 id=&quot;x05-&quot;&gt;0x05 编程语言&lt;/h2&gt;

&lt;p&gt;编程知识是必须的，虽然你可以通过网上的软件成为 hacker。在实际应用中你可能需要分析汇编码，高级程序代码，这是你对相应语言的熟悉程度能决定你 hack 的速度。 一般来说你需要学习 C、Java（C#）、Python（Ruby）和Lisp(Erlang、Haskell)这四种语言，因为这是四种不同的编程语言形态，学会这些后其它的语言也就上手快了。最新的语言中 Rust 很不错，我也正准备学习它。&lt;/p&gt;

&lt;p&gt;如果你作为 Web hacker，SQL 是你必须学会的一种语言，这种声明式语言好像还不错。&lt;/p&gt;

&lt;h2 id=&quot;x06-&quot;&gt;0x06 开源&lt;/h2&gt;

&lt;p&gt;hacker 社区是支持开源软件的一个大群体。当你可以贡献开源项目的时候，你应该积极参与开源项目，不管是技术上的、还是资金上的。通过参与开源项目你可以迅速提高你的编程能力，你可以自己开始一个项目，并持续更新，或者参加一个由另一个开源爱好者主导的项目。&lt;a href=&quot;http://github.com&quot;&gt;Github&lt;/a&gt;是一个很优秀的开源平台。这个平台有很多的优秀开源项目，围绕这个平台还有很多支持平台，都很不错。&lt;/p&gt;

&lt;h2 id=&quot;x07-linux&quot;&gt;0x07 Linux&lt;/h2&gt;

&lt;p&gt;MS Windows OS 可能对于大多数是用者来说是最简单的平台，但可能它并不适合所有 hacker，因为它屏蔽了太多的技术细节，你很难有成就感。MS Windows OS 上的 hacker 工具绝大多数是需要购买 license 的，但 Linux 上的工具你可以自己定制，我推荐大家使用 &lt;a href=&quot;http://kali.org&quot;&gt;Kali&lt;/a&gt;，这是一款专门为 hacker 设计的，集成了很多 hack 软件。 &lt;/p&gt;

&lt;h2 id=&quot;x08-end&quot;&gt;0x08 End&lt;/h2&gt;

&lt;p&gt;一个黑客的理想是成为高级测试工程师，具有发现别人发现不了的错误的能力。关于如何练习 hack、如何配置自己的环境、如何使用 hack 工具，有时间的时候另外开博吧。&lt;/p&gt;

</description>
      <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/security-how-to-become-a-hacker.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/security-how-to-become-a-hacker.html</guid>

      
      <category>Security</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>Git</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Git是一个分布式版本控制／软件配置管理软件，原是Linux内核开发者林纳斯·托瓦兹（Linus Torvalds）为更好地管理Linux内核开发而设计。本文记录了一些基本概念和基本操作，当然关于使用 Git 最重要的其实不是明白这些。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-git&quot;&gt;0x01 Git关键字&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;HEAD：指针
工作区
版本库(working tree)
暂存区(index)：add命令将文件添加到暂存区
已跟踪(staging)（未更新、已修改、已放入暂存区）
未跟踪(unstage)
仓库：commit将文件从暂存区添加到仓库
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 版本管理可以细分为&lt;/h2&gt;

&lt;p&gt;本地分支管理、远程分支管理、补丁管理、暂存（index）管理、&lt;/p&gt;

&lt;h2 id=&quot;x03-git&quot;&gt;0x03 Git安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x04-git&quot;&gt;0x04 Git配置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;name&quot;
git config --global user.email &quot;name@gmail.com&quot;
git config --global color.ui true
git config -l #list all the Git config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样配置完后，保存在~/。gitconfig&lt;/p&gt;

&lt;h2 id=&quot;x05-git&quot;&gt;0x05 Git查看帮助&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git help 
git help -show            #查看show命令的子命令
git add -h                #查看git add命令的帮助文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x06-git&quot;&gt;0x06 Git常用命令（查看、添加、提交、删除、找回、重置）&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git show 356f6def9d3fb7f3b9032ff5aa4b9110d4cca87e（哈希值，可以是具体某个文件的，也可以是某一次全部提交） 

checkout                              #重写工作区
git checkout（git checkout HEAD）     #汇总显示工作区、暂存区与HEAD的差异
git checkout master                   #取出master版本的HEAD
git checkout -- filename              #把filename文件从HEAD中checkouut。相当于取消自上次执行git add filename以来的本地修改。
git checkout branch --filename        #用branch分支filename 来替换暂存区和工作区文件。
git checkout . (git checkout -- .)    #用暂存区的文件代替所有现有项目文件。


git add              #命令主要用于把我们要提交的文件的信息添加到索引库(暂存区)中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。
git add filename     #
git add .            #将修改过的工作文件提交暂存区
git add -u           #表示 add to index only files modified or deleted and not those created 
git add -i [&amp;lt;path&amp;gt;]  #命令查看&amp;lt;path&amp;gt;中被所有修改过或已删除文件但没有提交的文件。

git commit                 #是将那些已经add到暂存区的文件commit到库中。
git commit filemame
git commit .
git commit -a              #将git add, git rm和git commit等操作都合并在一起做。
git comnit -m &quot;what u want to &quot;
git commit -am &quot;what u want to &quot;
git commit -amend          #?

git rm filename          #删除文件，并从版本库中删除。
git rm -r dire           #删除文件，并从库中移除。
git rm filename --cached #从版本库中删除文件，但不删除文件。

reset                                                    #命令可以去掉一些多余的状态和版本信息。
git reset [--hard|soft|mixed|merge|keep] [brank or HEAD] #reset命令是有mode的。
git reset filename
git reset -- .
git resert --hard                                        #恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改

git revert         #撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交
git revert HEAD    #撤销前一次commit
git revert HEAD^   #撤销前前一次commit
git revert &amp;lt;id&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x07-&quot;&gt;0x07 查看三区的不同&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git diff filename             #比较当前文件（工作区文件）和暂存区（索引区）文件的差异。
git diff &amp;lt;id&amp;gt; &amp;lt;id&amp;gt;            #比较两次提交之间的差异
git diff &amp;lt;branch1&amp;gt;..&amp;lt;branch2&amp;gt; # 在两个分支之间比较 
git diff --staged             # 比较暂存区和版本库差异
git diff --cached             # 比较暂存区和版本库差异
git diff --stat               # 仅仅比较统计信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x08-git-show&quot;&gt;0x08 查看提交记录和git show有些类似&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git log
git log &amp;lt;file&amp;gt;                   # 查看该文件每次提交记录
git log -p &amp;lt;file&amp;gt;                # 查看每次详细修改内容的diff
git log -p -2                    # 查看最近两次详细修改内容的diff
git log --stat                   # 查看提交统计信息
git log --pretty=oneline --graph #精简信息显示方式
git log --pretty=format:&quot;%h - %an, %ar : %s&quot; --graph
git log --pretty=oneline filename
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x09-&quot;&gt;0x09 本地分支管理&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git branch -r 
git br -r           # 查看远程分支
git br &amp;lt;new_branch&amp;gt; # 创建新的分支
git br -v           # 查看各个分支最后提交信息
git br --merged     # 查看已经被合并到当前分支的分支
git br --no-merged  # 查看尚未被合并到当前分支的分支

git co &amp;lt;branch&amp;gt;     # 切换到某个分支
git co -b &amp;lt;new_branch&amp;gt; # 创建新的分支，并且切换过去
git co -b &amp;lt;new_branch&amp;gt; &amp;lt;branch&amp;gt;  # 基于branch创建新的new_branch

git co $id          # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除
git co $id -b &amp;lt;new_branch&amp;gt;  # 把某次历史提交记录checkout出来，创建成一个分支

git br -d &amp;lt;branch&amp;gt;  # 删除某个分支
git br -D &amp;lt;branch&amp;gt;  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x10-rebase&quot;&gt;0x10 分支合并和rebase&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git merge &amp;lt;branch&amp;gt;               # 将branch分支合并到当前分支
git merge origin/master --no-ff  # 不要Fast-Foward合并，这样可以生成merge提交

git rebase master &amp;lt;branch&amp;gt;       # 将master rebase到branch，相当于：
git co &amp;lt;branch&amp;gt; &amp;amp;&amp;amp; git rebase master &amp;amp;&amp;amp; git co master &amp;amp;&amp;amp; git merge &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x11-git&quot;&gt;0x11 Git补丁管理&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git diff &amp;gt; ../sync.patch         # 生成补丁
git apply ../sync.patch          # 打补丁
git apply --check ../sync.patch  # 测试补丁能否成功
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x12-git&quot;&gt;0x12 Git暂存管理&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git stash                        # 暂存
git stash list                   # 列所有stash
git stash apply                  # 恢复暂存的内容
git stash drop                   # 删除暂存区
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x13-git&quot;&gt;0x13 Git远程分支管理&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git pull                         # 抓取远程仓库所有分支更新并合并到本地
git pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并
git fetch origin                 # 抓取远程仓库更新
git merge origin/master          # 将远程主分支合并到本地当前分支
git co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支
git co -b &amp;lt;local_branch&amp;gt; origin/&amp;lt;remote_branch&amp;gt;  # 基于远程分支创建本地分支，功能同上

git push                         # push所有分支
git push origin master           # 将本地主分支推到远程主分支
git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)
git push origin &amp;lt;local_branch&amp;gt;   # 创建远程分支， origin是远程仓库名
git push origin &amp;lt;local_branch&amp;gt;:&amp;lt;remote_branch&amp;gt;  # 创建远程分支
git push origin :&amp;lt;remote_branch&amp;gt;  #先删除本地分支(git br -d &amp;lt;branch&amp;gt;)，然后再push删除远程分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x14-git&quot;&gt;0x14 Git远程仓库管理&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git remote -v                    # 查看远程服务器地址和仓库名称
git remote show origin           # 查看远程服务器仓库状态
git remote add origin git@github:robbin/robbin_site.git         # 添加远程仓库地址
git remote set-url origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)
git remote rm &amp;lt;repository&amp;gt;       # 删除远程仓库
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x15-&quot;&gt;0x15 创建远程仓库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone --bare robbin_site robbin_site.git  # 用带版本的项目创建纯版本仓库
scp -r my_project.git git@git.csdn.net:~      # 将纯仓库上传到服务器上
mkdir robbin_site.git &amp;amp;&amp;amp; cd robbin_site.git &amp;amp;&amp;amp; git --bare init # 在服务器创建纯仓库
git remote add origin git@github.com:robbin/robbin_site.git    # 设置远程仓库地址
git push -u origin master                                      # 客户端首次提交
git push -u origin develop  # 首次将本地develop分支提交到远程develop分支，并且track
git remote set-head origin master   # 设置远程仓库的HEAD指向master分支
#也可以命令设置跟踪远程库和本地库
git branch --set-upstream master origin/master
git branch --set-upstream develop origin/develop
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sun, 26 Oct 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tools-git.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tools-git.html</guid>

      
      <category>Tool</category>
      

      
      <category>工具</category>
      
      
    </item>
  
    <item>
      <title>数据挖掘18大算法</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cs.uvm.edu/~icdm/algorithms/CandidateList.shtml&quot;&gt;国际权威的学术组织the IEEE International Conference on Data Mining (ICDM)&lt;/a&gt;2006年12月评选出了数据挖掘领域的十大经典算法：C4.5, k-Means, SVM, Apriori, EM, PageRank, AdaBoost, kNN, Naive Bayes, and CART。不仅仅是选中的十大算法，其实参加评选的18种算法，实际上随便拿出一种来都可以称得上是经典算法，它们在数据挖掘领域都产生了极为深远的影响。&lt;/p&gt;

&lt;h2 id=&quot;x01-classification----&quot;&gt;0x01 Classification  分类  (监督)&lt;/h2&gt;

&lt;h3 id=&quot;c45-------------------------------------rank-1&quot;&gt;C4.5                                     (rank: 1)&lt;/h3&gt;

&lt;p&gt;Quinlan, J. R. 1993. C4.5: Programs for Machine Learning.Morgan Kaufmann Publishers Inc.&lt;/p&gt;

&lt;p&gt;C4.5算法是机器学习算法中的一种分类决策树算法,其核心算法是ID3算法。决策树构造方法其实就是每次选择一个好的特征以及分裂点作为当前节点的分类条件。C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) 用信息增益率来选择属性，而不是信息增益，克服了用信息增益选择属性时偏向选择取值多的属性的不足；
2) 在树构造过程中进行剪枝，如果不剪枝，容易导致overfitting；
3) 能够完成对连续属性的离散化处理；
4) 能够对不完整数据进行处理。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C4.5算法有如下优点：产生的分类规则易于理解，准确率较高。其缺点是：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。&lt;/p&gt;

&lt;h3 id=&quot;cart--------------------------rank-10-&quot;&gt;CART: 分类与回归树                         (rank: 10 )&lt;/h3&gt;

&lt;p&gt;L. Breiman, J. Friedman, R. Olshen, and C. Stone. Classification and Regression Trees. Wadsworth, Belmont, CA, 1984.&lt;/p&gt;

&lt;p&gt;CART, Classification and Regression Trees。 在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。&lt;/p&gt;

&lt;h3 id=&quot;knn-k-nearest-neighbor-classification------rank-8&quot;&gt;kNN: k-nearest neighbor classification      (rank: 8)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/FengYan/archive/2012/07/13/2498277.html&quot;&gt;推荐系统相关算法(2)：k-nearest neighbor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hastie, T. and Tibshirani, R. 1996. Discriminant Adaptive Nearest Neighbor Classification. IEEE Trans. Pattern Anal. Mach. Intell. (TPAMI). 18, 6 (Jun. 1996), 607-616. DOI  http://dx.doi.org/10.1109/34.506411&lt;/p&gt;

&lt;p&gt;K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。&lt;/p&gt;

&lt;h3 id=&quot;naive-bayes----------------------------------rank-9&quot;&gt;Naive Bayes                                  (rank: 9)&lt;/h3&gt;

&lt;p&gt;Hand, D.J., Yu, K., 2001. Idiot’s Bayes: Not So Stupid After All? Internat. Statist. Rev. 69, 385-398.&lt;/p&gt;

&lt;p&gt;在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBC）。 朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以 及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。 但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属 性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。&lt;/p&gt;

&lt;h2 id=&quot;x02-statistical-learning--------------------------&quot;&gt;0x02 Statistical Learning  统计学习                        (监督)&lt;/h2&gt;

&lt;h3 id=&quot;support-vector-machines----------------------rank-3&quot;&gt;Support vector machines                      (rank: 3)&lt;/h3&gt;

&lt;p&gt;Vapnik, V. N. 1995. The Nature of Statistical Learning Theory. Springer-Verlag New York, Inc.&lt;/p&gt;

&lt;p&gt;支持向量机，英文为Support Vector Machine，简称SV机（论文中一般简称SVM）。它是一种监督式学习的方法，它广泛的应用于统计分类以及回归分析中。支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。分隔超平面使两个平行超平面的距离最大化。假 定平行超平面间的距离或差距越大，分类器的总误差越小。一个极好的指南是C.J.C Burges的《模式识别支持向量机指南》。van der Walt 和 Barnard 将支持向量机和其他分类器进行了比较。&lt;/p&gt;

&lt;h3 id=&quot;em----------------------------rank-5&quot;&gt;最大期望(EM)算法                            (rank: 5)&lt;/h3&gt;

&lt;p&gt;McLachlan, G. and Peel, D. (2000). Finite Mixture Models. J. Wiley, New York.&lt;/p&gt;

&lt;p&gt;在统计计算中，最大期望（EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然 估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。&lt;/p&gt;

&lt;h2 id=&quot;x03-association-analysis-----------------------&quot;&gt;0x03 Association Analysis 关联分析                     ( 无监督)&lt;/h2&gt;

&lt;h3 id=&quot;the-apriori-algorithm---------------------rank-4&quot;&gt;The Apriori algorithm                     (rank: 4)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://citeseer.comp.nus.edu.sg/agrawal94fast.html&quot;&gt;Rakesh Agrawal and Ramakrishnan Srikant. Fast Algorithms for Mining Association Rules. In Proc. of the 20th Int’l Conference on Very Large Databases (VLDB ‘94), Santiago, Chile, September 1994.&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;Apriori属于无监督学习, 它能够在合理的时间范围内找到频繁项集, 它基于 Apriori 原理, 从单元素项集开始, 通过组合满足最小支持度要求的项集来形成更大的集合。该算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。&lt;/p&gt;

&lt;p&gt;http://my.oschina.net/zenglingfan/blog/178392&lt;/p&gt;

&lt;h3 id=&quot;fp-tree&quot;&gt;FP-Tree&lt;/h3&gt;

&lt;p&gt;Han, J., Pei, J., and Yin, Y. 2000. Mining frequent patterns without candidate generation. In Proceedings of the 2000 ACM SIGMOD international Conference on Management of Data (Dallas, Texas, United States, May 15 - 18, 2000). SIGMOD ‘00. ACM Press, New York, NY, 1-12. DOI  http://doi.acm.org/10.1145/342009.335372&lt;/p&gt;

&lt;h2 id=&quot;x04-link-mining--&quot;&gt;0x04 Link Mining  链接挖掘&lt;/h2&gt;

&lt;h3 id=&quot;pagerank---------------rank-6&quot;&gt;PageRank               (rank: 6）&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/FengYan/archive/2011/11/12/2246461.html&quot;&gt;数据挖掘10大算法(1)——PageRank&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Brin, S. and Page, L. 1998. The anatomy of a large-scale hypertextual Web search engine. In Proceedings of the Seventh international Conference on World Wide Web (WWW-7) (Brisbane, Australia). P. H. Enslow and A. Ellis, Eds. Elsevier Science Publishers B. V., Amsterdam, The Netherlands, 107-117. DOI  http://dx.doi.org/10.1016/S0169-7552(98)00110-X   &lt;/p&gt;

&lt;p&gt;PageRank是Google算法的重要内容。2001年9月被授予美国专利，专利人是Google创始人之一拉里·佩奇（Larry Page）。因此，PageRank里的page不是指网页，而是指佩奇，即这个等级方法是以佩奇来命名的。&lt;/p&gt;

&lt;p&gt;PageRank根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票， 被链接的越多，就意味着被其他网站投票越多。这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自 学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。&lt;br /&gt;
http://www.cnblogs.com/FengYan/archive/2011/11/12/2246461.html&lt;/p&gt;

&lt;h3 id=&quot;hits&quot;&gt;HITS&lt;/h3&gt;

&lt;p&gt;http://blog.csdn.net/hguisu/article/details/8013489&lt;/p&gt;

&lt;p&gt;Kleinberg, J. M. 1998. Authoritative sources in a hyperlinked environment. In Proceedings of the Ninth Annual ACM-SIAM Symposium on Discrete Algorithms (San Francisco, California, United States, January 25 - 27, 1998). Symposium on Discrete Algorithms. Society for Industrial and Applied Mathematics, Philadelphia, PA, 668-677.&lt;/p&gt;

&lt;h2 id=&quot;x05-clustering------------------&quot;&gt;0x05 Clustering  聚类                (无监督)&lt;/h2&gt;

&lt;h3 id=&quot;the-k-means-algorithm-k-means-----rank-2&quot;&gt;The k-means algorithm 即K-Means算法     (rank: 2）&lt;/h3&gt;

&lt;p&gt;MacQueen, J. B., Some methods for classification and analysis of multivariate observations, in Proc. 5th Berkeley Symp. Mathematical Statistics and Probability, 1967, pp. 281-297.&lt;/p&gt;

&lt;p&gt;k-means algorithm算法是一个聚类算法，把n的对象根据他们的属性分为k个分割，k &amp;lt; n。它与处理混合正态分布的最大期望算法很相似，因为他们都试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均 方误差总和最小。&lt;/p&gt;

&lt;h3 id=&quot;birch&quot;&gt;BIRCH&lt;/h3&gt;
&lt;p&gt;http://baike.baidu.com/item/BIRCH?fr aladdin&lt;/p&gt;

&lt;p&gt;Zhang, T., Ramakrishnan, R., and Livny, M. 1996. BIRCH: an efficient data clustering method for very large databases. In Proceedings of the 1996 ACM SIGMOD international Conference on Management of Data (Montreal, Quebec, Canada, June 04 - 06, 1996). J. Widom, Ed. SIGMOD ‘96. ACM Press, New York, NY, 103-114. DOI  http://doi.acm.org/10.1145/233269.233324&lt;/p&gt;

&lt;h2 id=&quot;x06-bagging-and-boosting--&quot;&gt;0x06 Bagging and Boosting  袋装与推进&lt;/h2&gt;

&lt;h3 id=&quot;adaboost-----------------------------rank-7&quot;&gt;AdaBoost                             (rank: 7）&lt;/h3&gt;

&lt;p&gt;Freund, Y. and Schapire, R. E. 1997. A decision-theoretic generalization of on-line learning and an application to boosting. J. Comput. Syst. Sci. 55, 1 (Aug. 1997), 119-139. DOI  http://dx.doi.org/10.1006/jcss.1997.1504&lt;/p&gt;

&lt;p&gt;Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权 值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。&lt;/p&gt;

&lt;h2 id=&quot;x07-sequential-patterns--&quot;&gt;0x07 Sequential Patterns  序列模式&lt;/h2&gt;

&lt;h3 id=&quot;gsp&quot;&gt;GSP&lt;/h3&gt;

&lt;p&gt;Srikant, R. and Agrawal, R. 1996. Mining Sequential Patterns: Generalizations and Performance Improvements. In Proceedings of the 5th international Conference on Extending Database Technology: Advances in Database Technology (March 25 - 29, 1996). P. M. Apers, M. Bouzeghoub, and G. Gardarin, Eds. Lecture Notes In Computer Science, vol. 1057. Springer-Verlag, London, 3-17.&lt;/p&gt;

&lt;h3 id=&quot;prefixspan&quot;&gt;PrefixSpan&lt;/h3&gt;

&lt;p&gt;J. Pei, J. Han, B. Mortazavi-Asl, H. Pinto, Q. Chen, U. Dayal and M-C. Hsu. PrefixSpan: Mining Sequential Patterns Efficiently by Prefix-Projected Pattern Growth. In Proceedings of the 17th international Conference on Data Engineering (April 02 - 06, 2001). ICDE ‘01. IEEE Computer Society, Washington, DC.&lt;/p&gt;

&lt;h2 id=&quot;x08-integrated-mining--&quot;&gt;0x08 Integrated Mining  集成挖掘&lt;/h2&gt;

&lt;h3 id=&quot;cba&quot;&gt;CBA&lt;/h3&gt;

&lt;p&gt;[Liu, B., Hsu, W. and Ma, Y. M. Integrating classification and association rule mining. KDD-98, 1998, pp. 80-86.]（http://citeseer.comp.nus.edu.sg/liu98integrating.html）&lt;/p&gt;

&lt;h2 id=&quot;x09-rough-sets-&quot;&gt;0x09 Rough Sets 粗糙集&lt;/h2&gt;

&lt;p&gt;粗糙集主要用于人工智能中的知识发现领域&lt;br /&gt;
http://wenku.baidu.com/link?url cD2Z12Gt6YDSLY5N0LW-KsAhFi8EuBGXv0kBO561RvsCa5p9FvJXfTV4OI9bXZWJ1ZE_kGQgq6g6uALGEW_AvTCa_Ay6PZ0gKpIv_w-pBQC&lt;/p&gt;

&lt;h3 id=&quot;finding-reduct&quot;&gt;Finding reduct&lt;/h3&gt;

&lt;p&gt;Zdzislaw Pawlak, Rough Sets: Theoretical Aspects of Reasoning about Data, Kluwer Academic Publishers, Norwell, MA, 1992&lt;/p&gt;

&lt;h2 id=&quot;x10-graph-mining--&quot;&gt;0x10 Graph Mining  图挖掘&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.docin.com/p-717638445.html&quot;&gt;浅析Social_Network和Graph_Mining_的应用和机器学习技&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;gspan&quot;&gt;gSpan&lt;/h3&gt;

&lt;p&gt;Yan, X. and Han, J. 2002. gSpan: Graph-Based Substructure Pattern Mining. In Proceedings of the 2002 IEEE International Conference on Data Mining (ICDM ‘02) (December 09 - 12, 2002). IEEE Computer Society, Washington, DC.&lt;/p&gt;

</description>
      <pubDate>Fri, 10 Oct 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tech-data-mining-18-algrithms.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tech-data-mining-18-algrithms.html</guid>

      
      <category>数据挖掘</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>Windows 2003</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;熟悉任何东西都不可能完全重头开始，最佳的实践是：重一个经典模型开始，不断重复这个经典的模式，不断的通过经典补充你缺失的概念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 自动登陆&lt;/h2&gt;

&lt;p&gt;方法1：打开注册表(运行-&amp;gt;“Regedit”)，再打开: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HKEY_LOCAL_MACHIN|SOFTWARE|MicroSoft|Windows NT|CurrentVersion |Winlogon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此段中按右键，新建 二个字符串段，AutoAdminLogon=“1”，DefaultPassword=“Password”。 注意，一定要为Administrator设置一个密码，否则不能实现自启动。 然后，重新启动 Windows即可实现自动登录。 &lt;/p&gt;

&lt;p&gt;方法2：管理工具 -&amp;gt; Local Security Settings（本地安全策略） -&amp;gt; 本地策略 -&amp;gt; 安全选项 -&amp;gt; interactive logon: Do not require CTRL+ALT+DEL，启用之。 &lt;/p&gt;

</description>
      <pubDate>Sat, 02 Aug 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tech-setup-windows-server-2003.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tech-setup-windows-server-2003.html</guid>

      
      <category>Windows</category>
      
      <category>Setup</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>网络中关键设备</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;网络上的设备不是从一开始就时这样丰富的，是在其短暂的历史中，由于不同的需求的出现，用来解决不同的问题。当你在心中建立来他们的场景变化，其实关于网络的进化历史，你已经懂得了一点点^^。当然每一层都存在不同的路由算法。这些也不是问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 物理层设备&lt;/h2&gt;

&lt;p&gt;中继器：repeater，为模拟设备，用来连接两根电缆段，以延长网络距离的互联设备，属于物理层，起信号的放大和中转作用。中继器并不关心帧、分组和头，只关心电压值。&lt;/p&gt;

&lt;p&gt;集线器：Hub，是一种共享设备，类似一个多端口的中继器，也属于物理层。集线器有许多条的输入线路，他将这些输入线路连接起来。在任何一条线路上到达的帧都将被发送到所有其他的线路上。如果两帧同时到达，则他们将会冲突，就好像他们在同一根线路上一样。也就是说，整个集线器构成了一个冲突域，连接在同一个集线器上的所有线路必须运行在同样的速度上。与中继器不同的是，集线器不对输入的信号进行放大。&lt;/p&gt;

&lt;h2 id=&quot;x02-&quot;&gt;0x02 二层设备（数据链路层）&lt;/h2&gt;

&lt;p&gt;网桥：bridge，连接多个不同LAN的设备（如802.3到802.11），运行在数据链路层上，通过查看数据链路层的地址（即MAC地址）完成帧转发的任务（即可以判断一个数据帧是属于网络A还是网络B），同时可以分割因域内集线器过多造成的广播风暴。类似一个底层的路由器（路由器工作在网络层，根据网络地址进行转发）。注意和中继器的区别：中继器复制所有他看到的数据，而网桥则可以区别对待那些该转发的和不该转发的数据。另外，网桥中的每条线路都有他自己的冲突域，这个与集线器不同。&lt;/p&gt;

&lt;p&gt;交换机：Switch，基于MAC地址识别，能完成封装、转发数据包功能的网络设备，工作在数据链路层。由于交换机中有一张路由表，如果找到目标地址就可以将数据发送到指定地址，否则发送到所有端口；而集线器只是将数据广播发送到所有的端口，因此速度较交换机慢。交换机一般用在连接独立的计算机，而网桥一般用来连接独立的LAN。现在有些交换机为提高帧的传送速度，不采用传统的存储-转发模式，而是直通型交换模式，即一旦目标头域已经进来而输出线路又可以使用，就传送该帧。&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 三层设备（网络层）&lt;/h2&gt;

&lt;p&gt;路由器：Router。工作在网络层。根据分组信息选择路由线路，类似网桥。由于在网路层，帧头和帧尾已经被剥掉，因此路由器并不知道帧信息，也不知道该分组来自于哪个LAN。&lt;/p&gt;

&lt;p&gt;网关：Gateway，有传输网关和应用网关，分别工作在传输层和应用层。&lt;/p&gt;

&lt;h2 id=&quot;x04-&quot;&gt;0x04 网桥难点&lt;/h2&gt;

&lt;p&gt;下面关注网桥处理帧的几个难点（以从802.11到802.3为例）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不同的LAN使用的帧格式不同，因此在复制操作时需要重新填充格式。&lt;/li&gt;
  &lt;li&gt;不同的LAN工作的速率不尽相同，网桥需要尽快的转发这些数据。&lt;/li&gt;
  &lt;li&gt;不同的LAN有不同的最大帧长度，若不匹配则会丢弃（把帧分成小片不属于数据链路层协议该提供的功能）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本地网桥的路由算法：&lt;/p&gt;

&lt;p&gt;网桥通过其内部的一张大的散列表，查找一帧的目标地址。该散列表列出了每一个可能的目标地址，并指明了该帧属于哪一条输出线路（LAN）。当最初网桥被插入进来的时候，所以的散列表都是空的，所有的网桥都不知道哪个目标地址该往哪里去，因此网桥采用逆向学习法（backwardlearning。通过检测来自LAN1的帧的源地址A判断可从LAN1到达地址A）记录这些目标地址。当机器和网桥被加电或断电或移动异地时，网桥中的定期扫描散列表进程会清空对应表项。&lt;/p&gt;

&lt;p&gt;对于一个进入网桥的帧，该帧在网桥中如何被路由取决于他在哪个LAN上到达以及他的目标地址在哪个LAN上，过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果目标LAN和源LAN相同，则丢弃该帧，不转发；&lt;/li&gt;
  &lt;li&gt;如果目标LAN和源LAN不相同，则转发该帧；&lt;/li&gt;
  &lt;li&gt;如果目标LAN未知，即散列表中无该目标LAN，则使用扩散法，广播输出到所有接入的LAN中（除了进入的那个LAN）。&lt;/li&gt;
&lt;/ol&gt;

</description>
      <pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/network-wang-luo-zhong-guan-jian-she-bei-de-qu-bie.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/network-wang-luo-zhong-guan-jian-she-bei-de-qu-bie.html</guid>

      
      <category>Network</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>端口映射</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;内网的一台电脑要上因特网，就需要端口映射，端口映射分为动态和静态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-&quot;&gt;0x01 端口映射&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;动态端口映射&lt;/h3&gt;
&lt;p&gt;内网中的一台电脑要访问新浪网，会向NAT网关发送数据包，包头中包括对方(就是新浪网)IP、端口和本机IP、端口，NAT网关会把本机IP、端口替换成自己的公网IP、一个未使用的端口，并且会记下这个映射关系，为以后转发数据包使用。然后再把数据发给新浪网，新浪网收到数据后做出反应，发送数据到NAT网关的那个未使用的端口，然后NAT网关将数据转发给内网中的那台电脑，实现内网和公网的通讯.当连接关闭时，NAT网关会释放分配给这条连接的端口，以便以后的连接可以继续使用。 动态端口映射其实就是NAT网关的工作方式。 &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;静态端口映射&lt;/h3&gt;
&lt;p&gt;就是在NAT网关上开放一个固定的端口，然后设定此端口收到的数据要转发给内网哪个IP和端口，不管有没有连接，这个映射关系都会一直存在。就可以让公网主动访问内网的一个电脑。NAT网关可以是交换机、路由器或电脑。 &lt;/p&gt;

&lt;h2 id=&quot;x02-nat&quot;&gt;0x02 什么是内网、什么是公网、什么是NAT？&lt;/h2&gt;

&lt;p&gt;现在很多关于端口映射的文章都严重的误导人，许多不懂的人把端口映射软件用在自己的电脑上，其实端口映射是要在网关上做的！！！而网关很少是电脑，大部分人也不能控制网关，所以那几个端口映射的软件基本没用。 &lt;/p&gt;

&lt;p&gt;NAT原理简介、各种 ADSL Modem 及路由器的端口映射方法 &lt;/p&gt;

&lt;h2 id=&quot;x03-nat&quot;&gt;0x03 NAT原理简介&lt;/h2&gt;

&lt;p&gt;NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。 &lt;/p&gt;

&lt;p&gt;简单地说，NAT就是在局域网内部网络中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关（可以理解为出口，打个比方就像院子的门一样）处，将 内部地址替换成公用地址，从而在外部公网（internet）上正常使用，NAT可以使多台计算机共享Internet连接，这一功能很好地解决了公共 IP地址紧缺的问题。通过这种方法，您可以只申请一个合法IP地址，就把整个局域网中的计算机接入Internet中。这时，NAT屏蔽了内部网络，所有内部网计算机对于公共网络来说是不可见的，而内部网计算机用户通常不会意识到NAT的存在。如图2所示。这里提到的内部地址，是指在内部网络中分配给节点 的私有IP地址，这个地址只能在内部网络中使用，不能被路由（一种网络技术，可以实现不同路径转发）。虽然内部地址可以随机挑选，但是通常使用的是下面的 地址：10.0.0.0~10.255.255.255，172.16.0.0~172.16.255.255，192.168.0.0~192.168.255.255。NAT将这些无法在互联网上使用的保留IP地址翻译成可以在互联网上使用的合法IP地址。而全 局地址，是指合法的IP地址，它是由NIC（网络信息中心）或者ISP(网络服务提供商)分配的地址，对外代表一个或多个内部局部地址，是全球统一的可寻 址的地址。 &lt;/p&gt;

&lt;p&gt;NAT 功能通常被集成到路由器、防火墙、ISDN路由器或者单独的NAT设备中。比如Cisco路由器中已经加入这一功能，网络管理员只需在路由器的IOS中设 置NAT功能，就可以实现对内部网络的屏蔽。再比如防火墙将WEB Server的内部地址192.168.1.1映射为外部地址202.96.23.11，外部访问202.96.23.11地址实际上就是访问访问 192.168.1.1。另外资金有限的小型企业来说，现在通过软件也可以实现这一功能。Windows 98 SE、Windows 2000 都包含了这一功能。 &lt;/p&gt;

&lt;h2 id=&quot;x04-nat&quot;&gt;0x04 NAT技术类型&lt;/h2&gt;

&lt;p&gt;NAT有三种类型：静态NAT(Static NAT)、动态地址NAT(Pooled NAT)、网络地址端口转换NAPT（Port－Level NAT）。 &lt;/p&gt;

&lt;p&gt;其中静态NAT设置起来最为简单和最容易实现的一种，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。而动态地址NAT则是在外部网络中定 义了一系列的合法地址，采用动态分配的方法映射到内部网络。NAPT则是把内部地址映射到外部网络的一个IP地址的不同端口上。根据不同的需要，三种 NAT方案各有利弊。 &lt;/p&gt;

&lt;p&gt;动态地址NAT只是转换IP地址，它为每一个内部的IP地址分配一个临时的外部IP地址，主要应用于拨号，对于频繁的远程联接也可以采用动态NAT。当远程用户联接上之后，动态地址NAT就会分配给他一个IP地址，用户断开时，这个IP地址就会被释放而留待以后使用。 &lt;/p&gt;

&lt;p&gt;网络地址端口转换NAPT（Network Address Port Translation）是人们比较熟悉的一种转换方式。NAPT普遍应用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与 动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。 在Internet 中使用NAPT时，所有不同的信息流看起来好像来源于同一个IP地址。这个优点在小型办公室内非常实用，通过从ISP处申请的一个IP地址，将多个连接通 过NAPT接入Internet。实际上，许多SOHO远程访问设备支持基于PPP的动态IP地址。这样，ISP甚至不需要支持NAPT，就可以做到多个内部IP地址共用一个外部IP地址上Internet，虽然这样会导致信道的一定拥塞，但考虑到节省的ISP上网费用和易管理的特点，用NAPT还是很值 得的。 &lt;/p&gt;

&lt;p&gt;ADSL Modem 的端口映射讲解，如果ADSL本身就带有路由功能，就需要在ADSL的“管理界面”中设置相应的端口映射。 设置的方法可能会因为ADSL不同的品牌和型号，在设置的方法上也会有所不同。我们收集和总结了一些常见ADSL的端口映射的方法，请大家参照相关的型号 进行设置。如果你所使用的ADSL猫不在我们总结的范围之内，请PM给我们，我们会尽快想办法补充上的。&lt;/p&gt;

</description>
      <pubDate>Thu, 17 Jul 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/network-duan-kou-ying-she.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/network-duan-kou-ying-she.html</guid>

      
      <category>Network</category>
      

      
      <category>技术</category>
      
      
    </item>
  
    <item>
      <title>Octopress</title>
      <description>&lt;h2 id=&quot;x00-&quot;&gt;0x00 引言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Octopress是一款基于 Jekyll 的优秀的静态化博客系统，也是一个本地化的博客系统。如果你是 Github 深度用户，一定知道可用用 Github Pages 托管静态 Blog。学计算机，就应该多动手，这样才能有成就感。作为一名动手的 programer 还是需要一个 Blog 的。不过我现在已经不用 Octopress 搭建的 Blog 了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;x01-github&quot;&gt;0x01 什么是github?&lt;/h2&gt;

&lt;p&gt;github 是一个源代码托管平台，有很多类似的比如gitcafe等。&lt;/p&gt;

&lt;h3 id=&quot;github-pages&quot;&gt;什么是github pages?&lt;/h3&gt;

&lt;p&gt;github pages 是github的一个创新，来增加github的layers。更多有关github pages的文档，见：&lt;a href=&quot;http://pages.github.com/&quot;&gt;http://pages.github.com/&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;github-pages-1&quot;&gt;为什么用github pages?&lt;/h3&gt;

&lt;p&gt;用github pages搭建博客，你可以享受到免费的服务器，免费的流量和相对不错的服务体验。另外，这种blog对于控制欲强悍的程序员来说，很适合，一切由你决定，还有近乎0成本迁移到任意服务器。&lt;/p&gt;

&lt;h2 id=&quot;x02-octopress&quot;&gt;0x02 什么是octopress?&lt;/h2&gt;

&lt;p&gt;octopress提供了一组自动化的工具和模版帮助用户简化博客系统的创建。octopress生成的博客系统可以被方便地部署到github pages及heroku，当然，由于生成的是静态文件，你也可以将其部署到任何一个你自己的vhost或server。&lt;/p&gt;

&lt;p&gt;octopress的安装文档见：&lt;a href=&quot;http://octopress.org/docs/setup/&quot;&gt;http://octopress.org/docs/setup/&lt;/a&gt;。本文接下来的部分会详细介绍如何用github pages和octopress部署一个自己的博客，及简单介绍如何进行写作。&lt;/p&gt;

&lt;h2 id=&quot;x03-&quot;&gt;0x03 安装&lt;/h2&gt;

&lt;h3 id=&quot;repository&quot;&gt;创建博客repository项目&lt;/h3&gt;

&lt;p&gt;在你的github账号下创建名为yourname.github.com的repository项目。&lt;/p&gt;

&lt;h3 id=&quot;ruby-git&quot;&gt;安装ruby ，git&lt;/h3&gt;

&lt;p&gt;如果你的系统中没有ruby或者 &lt;code&gt;ruby --version&lt;/code&gt; 的版本不是1.9.3，请使用 &lt;a href=&quot;https://rvm.io/rvm/install/&quot;&gt;rvm&lt;/a&gt; 或者你熟悉的version manager安装1.9.3.&lt;/p&gt;

&lt;p&gt;使用rvm安装ruby 1.9.3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -L https://get.rvm.io | bash -s stable --ruby   #安装rvm
$ sudo apt-get install git ruby ruby-dev -y
$ rvm install 1.9.3
$ rvm use 1.9.3
$ rvm rubygems latest
ruby 1.9.3p0 (2011-10-30 revision 33570) [x86_64-darwin12.2.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;octopress&quot;&gt;设置octopress&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;安装依赖&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/imathis/octopress.git octopress
$ cd octopress
$ gem install bundler
$ bundle install   #不要用root权限，使用root权限后以后不能再用普通用户
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;安装缺省的模版&lt;/h4&gt;

&lt;p&gt;使用rake install 后会产生三个目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source:来自于.themes\classic目录中的source，并添加来_posts目录
sass:来自于.themes\classic目录中的source
public: 

$ rake install
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;repository-1&quot;&gt;设置博客使用的repository&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ rake setup_github_pages
Enter the read/write url for your repository
(For example, &#39;git@github.com:your_username/your_username.github.com)
Repository url: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请输入：&lt;code&gt;git@github.com:yourname/yourname.github.com.git&lt;/code&gt; (将yourname替换成你的github登录名)&lt;/p&gt;

&lt;p&gt;这个步骤rake会做很多事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在.git/config中替换origin为你输入的repository，并把原来的origin写到octopress中。&lt;/li&gt;
  &lt;li&gt;创建新的branch source并切换到这个branch。&lt;/li&gt;
  &lt;li&gt;在生成的_deploy目录下，初始化git repository为你的repository。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是两个git config的内容，just for your information。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/projects/octopress$ cat .git/config 
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
[remote &quot;octopress&quot;]
	url = git://github.com/imathis/octopress.git
	fetch = +refs/heads/*:refs/remotes/octopress/*
[branch &quot;source&quot;]
	remote = origin
	merge = refs/heads/master
	rebase = true
[remote &quot;origin&quot;]
	url = git@github.com:tyrchen/tyrchen.github.com.git
	fetch = +refs/heads/*:refs/remotes/origin/*

~/projects/octopress$ cat _deploy/.git/config 
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
[remote &quot;origin&quot;]
	url = git@github.com:tyrchen/tyrchen.github.com.git
	fetch = +refs/heads/*:refs/remotes/origin/*
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;创建博文&lt;/h4&gt;

&lt;p&gt;接下来可以试试创建一个新的博文：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake new_post[&quot;My first blog&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会在source/_posts下创建一个以时间和标题为名称的markdown文件，它就是你的第一篇博文。&lt;/p&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake preview
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rake会启动一个server，打开浏览器访问 &lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt; 可以看到你的最新更改。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;部署你的博客&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ rake gen_deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会把_deploy下的内容重新生成一遍，然后提交到你的repository。但你并不能立马访问你的博客，需要等待几分钟的样子。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;保存你的更改&lt;/h4&gt;

&lt;p&gt;当你完成修改后，需要使用git工具提交修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &quot;notes&quot;
$ git push origin source    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一句可以不要，这样源代码就不会上传&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;撰写博文&lt;/h4&gt;

&lt;p&gt;博客系统搭建好之后，如何撰写博文呢？你要使用 &lt;code&gt;rake new_post&lt;/code&gt; 命令创建一篇新的文章，然后使用称手的markdown编辑器进行编辑即可。可选择的markdown编辑器很多，vim，sublime text 2，textmate 2等等。我个人喜欢sublime text 2。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;个性化&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;添加个人域名&lt;/h3&gt;
&lt;p&gt;在octopress目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;blog.yourdomain.com&#39; &amp;gt;&amp;gt; source/CNAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的DNS服务商，如 &lt;a href=&quot;http://dnspod.cn&quot;&gt;dnspod.cn&lt;/a&gt;，添加相应的CNAME指向 yourname.github.com。如果你要使用顶级域名，如 &lt;code&gt;http://yourdomain.com&lt;/code&gt; 访问你的博客，则需要使用A记录指向 &lt;code&gt;207.97.227.245&lt;/code&gt;。详细内容请参考：&lt;a href=&quot;http://octopress.org/docs/deploying/github/&quot;&gt;http://octopress.org/docs/deploying/github/&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;设置博客&lt;/h3&gt;

&lt;p&gt;主要设置文件包括：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_config.yml       # Main config (Jekyll&#39;s settings)
Rakefile          # Configs for deployment
config.rb         # Compass config
config.ru         # Rack config 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要设置内容：&lt;br /&gt;
    设置网站的description和keywords&lt;br /&gt;
    设置首页&lt;br /&gt;
    导航栏设置&lt;br /&gt;
    设置文件版权&lt;br /&gt;
按照 &lt;a href=&quot;http://octopress.org/docs/configuring/&quot;&gt;http://octopress.org/docs/configuring/&lt;/a&gt; 的说明进行设置即可。注意把不需要的asides都删除，免得加载不必要的js，拖累访问速度。&lt;/p&gt;

&lt;h2 id=&quot;x04-configyml-&quot;&gt;0x04 我的_config.yml 的配置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;url: http://chez-guile.github.io
title: Chez
subtitle: 一个迷失的人
author: Chez-Guile
simple_search: http://google.com/search
description: Hello Everyone. I am a Vimer,Emacser and i am using Ubuntu,Now.

github_user: Chez-Guile
github_repo_count: 1
github_show_profile_link: true
github_skip_forks: true

# Disqus Comments
disqus_short_name: chezguile
disqus_show_comment_count: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;使用主题&lt;/h3&gt;

&lt;p&gt;本文使用了 &lt;a href=&quot;https://github.com/shashankmehta/greyshade&quot;&gt;https://github.com/shashankmehta/greyshade&lt;/a&gt; 的主题。使用方法很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd octopress
$ git clone git@github.com:shashankmehta/greyshade.git .themes/greyshade
$ echo &quot;\$greyshade: color;&quot; &amp;gt;&amp;gt; sass/custom/_colors.scss //Substitue &#39;color&#39; with your highlight color 0x000000
$ rake &quot;install[greyshade]&quot;
$ rake generate
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;更新&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git pull octopress master     # Get the latest Octopress
bundle install                # Keep gems updated
rake update_source            # update the template&#39;s source
rake update_style             # update the template&#39;s style
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x05-&quot;&gt;0x05 常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ rake setup_github_pages
$ rake new_post[&quot;name&quot;]
$ rake generate
$ rake preview
$ rake watch   # 监控source 和sass 目录的变动
$ rake deploy
$ rake gen_deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x06-&quot;&gt;0x06 所需工具&lt;/h2&gt;

&lt;p&gt;git rvm(这个工具的使用还是应该学会的) edit ruby &lt;/p&gt;

&lt;h2 id=&quot;x07-&quot;&gt;0x07 常见错误及其解决方案&lt;/h2&gt;

&lt;p&gt;1：Make sure that &lt;code&gt;gem install RedCloth -v &#39;4.2.9&#39;&lt;/code&gt; succeeds before bundling.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2：RVM is not a function, selecting rubies with ‘rvm use …’ will not work.&lt;br /&gt;
You need to change your terminal settings to allow shell login.&lt;br /&gt;
Please visit https://rvm.io/workflow/screen/ for example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bash --login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3：这个文件名不能出现标点符号。数字和数学符号&lt;/p&gt;

&lt;p&gt;4：You have already activated rake 0.9.2.2, but your Gemfile requires rake 0.9.2. Consider using bundle exec.&lt;/p&gt;

&lt;p&gt;可以在rake install命令前添加bundle exec或者直接修改octopress目录文件Gemfile,修改rake版本为当前版本&lt;/p&gt;

&lt;p&gt;5：/home/chez/.rvm/gems/ruby-1.9.3-p547/gems/execjs-2.2.2/lib/execjs/runtimes.rb:51:in `autodetect’: Could not find a JavaScript runtime. See https://github.com/sstephenson/execjs for a list of available runtimes. (ExecJS::RuntimeUnavailable)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x07--1&quot;&gt;0x07 参考文献&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://octopress.org&quot;&gt;Octopress&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://justcoding.iteye.com/blog/1959737&quot;&gt;Octopress 配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
      <pubDate>Sun, 29 Jun 2014 00:00:00 +0800</pubDate>
      <link>https://danielyangmeta.github.com//2014/tools-How-to-use-Octopress.html</link>
      <guid isPermaLink="true">https://danielyangmeta.github.com//2014/tools-How-to-use-Octopress.html</guid>

      
      <category>Tool</category>
      

      
      <category>工具</category>
      
      
    </item>
          

  </channel>
</rss>